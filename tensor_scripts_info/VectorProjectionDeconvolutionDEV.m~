
function [] =VectorProjectionDeconvolution(tensorn1)
%%
close all


%% Enter Cij read in as a single row vector with all 21 values: C11 C12 C13 C14 C15 C16 C22 C21... etc %%
tensorn1 = double(tensorn1);
Data = xlsread('DB_Tensors_Rhos_OrigOrientation.xlsx');
Tensors = Data(tensorn1,4:24)

% Breakdown will be a table of symmetry components for each sample. 
% Columns are: [Iso Hex Ortho Tet Mon Tric 0 0 Backus' Love_A Love_C Love_F Love_L Love_N Eta EtaK Eigs2' Bisectrix(:,1)' Bisectrix(:,2)' Bisectrix(:,3)'];
% The last 9 columns are the orientations of the 1, 2, and 3 symmetry cartesian
% coordinate system axes, 3 is the symmetry axis.
Breakdown = zeros(length(Tensors(:,1)),32);

% Nothing currently happens with these next 3 things, but you could use
% them to save the respective tensors
% Rotated to symmetry axis
SymmetryAxis = zeros(length(Tensors(:,1)),21);
% Isotropic component
IsoComponent = zeros(length(Tensors(:,1)),21);
% Hexagonal component
HexagonalComponent = zeros(length(Tensors(:,1)),21);

for s = 1:length(Tensors(:,1))

C1 = [Tensors(s,1) Tensors(s,2) Tensors(s,3) Tensors(s,4) Tensors(s,5) Tensors(s,6);...
    Tensors(s,2) Tensors(s,7) Tensors(s,8) Tensors(s,9) Tensors(s,10) Tensors(s,11);...
    Tensors(s,3) Tensors(s,8) Tensors(s,12) Tensors(s,13) Tensors(s,14) Tensors(s,15);...
    Tensors(s,4) Tensors(s,9) Tensors(s,13) Tensors(s,16) Tensors(s,17) Tensors(s,18);...
    Tensors(s,5) Tensors(s,10) Tensors(s,14) Tensors(s,17) Tensors(s,19) Tensors(s,20);...
    Tensors(s,6) Tensors(s,11) Tensors(s,15) Tensors(s,18) Tensors(s,20) Tensors(s,21)];

%% Create dij and vij for eigenvector calculation (dilational and Voigt contractions)
dij = [C1(1,1)+C1(1,2)+C1(1,3), C1(1,6)+C1(2,6)+C1(3,6), C1(1,5)+C1(2,5)+C1(3,5);...
    C1(1,6)+C1(2,6)+C1(3,6), C1(1,2)+C1(2,2)+C1(3,2), C1(1,4)+C1(2,4)+C1(3,4);...
    C1(1,5)+C1(2,5)+C1(3,5), C1(1,4)+C1(2,4)+C1(3,4), C1(1,3)+C1(2,3)+C1(3,3)];

vij = [C1(1,1)+C1(6,6)+C1(5,5), C1(1,6)+C1(2,6)+C1(4,5), C1(1,5)+C1(3,5)+C1(4,6);...
    C1(1,6)+C1(2,6)+C1(4,5), C1(6,6)+C1(2,2)+C1(4,4), C1(2,4)+C1(3,4)+C1(5,6);...
    C1(1,5)+C1(3,5)+C1(4,6), C1(2,4)+C1(3,4)+C1(5,6), C1(5,5)+C1(4,4)+C1(3,3)];
%% Calculate eigenvectors and eigenvalues
[eigenvecs_d, eigenvals_d] = eig(dij);
[eigenvecs_v, eigenvals_v] = eig(vij);
Eigs = diag(eigenvals_d,0);
Eigs2 = diag(eigenvals_v,0);

% This loop sorts eigenvectors to have most unique axis last. 
A1 = Eigs(2)-Eigs(1);
A2 = Eigs(3)-Eigs(2);

A12 = Eigs2(2)-Eigs2(1);
A22 = Eigs2(3)-Eigs2(2);
if A1<A2
else
    eigenvecs_d = eigenvecs_d(:,[3,2,1]);
    Eigs = Eigs([3,2,1]);
end

if A12<A22
else
    eigenvecs_v = eigenvecs_v(:,[3,2,1]);
    Eigs2 = Eigs2([3,2,1]);
end

%% Calculate bisecting vectors between the nearest eigenvectors of dij and vij
% Calculate angles between all of the eigenvectors, and the negative of dij
% eigenvectors in case some are close to 180?
for i = 1:3
for j = 1:3
   Ang(i,j) = acosd(dot(eigenvecs_v(:,i),eigenvecs_d(:,j)));
   Ang2(i,j) = acosd(dot(eigenvecs_v(:,i),-1*eigenvecs_d(:,j)));
end
end
eVd = eigenvecs_d;
AngF = Ang;
% Use the negative of the eigenvectors if the angle is closer.
for i = 1:3
    if min(Ang2(:,i))<min(Ang(:,i))
        eVd(:,i) = -1*eVd(:,i);
        AngF(:,i) = Ang2(:,i);
    else
    end
end
% Calculate the bisecting vectors and normalize length
for i = 1:3 

        I = find(AngF(:,i)==min(AngF(:,i)));
        BA(i) = I;
        Bisectrix(:,i) = (eigenvecs_v(:,I) + eVd(:,i))/2;
        Bisectrix(:,i) = Bisectrix(:,i)./norm(Bisectrix(:,i));
        
end

% Because the bisectors are not guaranteed to be exactly perpendicular,
% make them perpendicular using cross product
Bisectrix1 = Bisectrix;
Bisectrix1(:,1) = cross(Bisectrix1(:,3),Bisectrix1(:,2));
Bisectrix1(:,2) = cross(Bisectrix1(:,1),Bisectrix1(:,3));

% Try all permutations of Bisectrix
Bisectrix_All = {Bisectrix1;Bisectrix1(:,[1,3,2]);Bisectrix1(:,[2,1,3]);...
    Bisectrix1(:,[2,3,1]);Bisectrix1(:,[3,1,2]);Bisectrix1(:,[3,2,1])};
    
%% Variables to save the decomp results into for determining *best* bisectrix
IsoA = zeros(length(Bisectrix_All),1);
HexA = zeros(length(Bisectrix_All),1);
TetA = zeros(length(Bisectrix_All),1);
OrthoA = zeros(length(Bisectrix_All),1);
MonA = zeros(length(Bisectrix_All),1);
TricA = zeros(length(Bisectrix_All),1);

% do the decomposition for every permutation
for btrix = 1:length(Bisectrix_All)
%% Do basis change from x,y,z to bisectrix. i.e. rotate into symmetry axis orientation.
Omega = Bisectrix_All{btrix}';
K1 = Omega.^2;
for i = 1:3
    for j = 1:3
        K2(i,j) = Omega(i,round(mod(j+1,3.00001)))*Omega(i,round(mod(j+2,3.000001)));
        K3(i,j) = Omega(round(mod(i+1,3.0000001)),j)*Omega(round(mod(i+2,3.0000001)),j);
        K4(i,j) = Omega(round(mod(i+1,3.000001)),round(mod(j+1,3.000001)))*Omega(round(mod(i+2,3.000001)),round(mod(j+2,3.000001)))...
            +Omega(round(mod(i+1,3.000001)),round(mod(j+2,3.000001)))*Omega(round(mod(i+2,3.000001)),round(mod(j+1,3.000001)));
    end
end
K = [K1 2*K2; K3 K4];
C = K*C1*K';
SymmetryAxis(s,:) = [C(1,1:6) C(2,2:6) C(3,3:6) C(4,4:6) C(5,5:6) C(6,6)];
%% Create vector for projection decomposition
Vec_1 = [C(1,1);C(2,2);C(3,3);sqrt(2)*C(2,3);sqrt(2)*C(1,3);sqrt(2)*C(1,2);...
    2*C(4,4);2*C(5,5);2*C(6,6);2*C(1,4);2*C(2,5);2*C(3,6);2*C(3,4);2*C(1,5);...
    2*C(2,6);2*C(2,4);2*C(3,5);2*C(1,6);2*sqrt(2)*C(5,6);2*sqrt(2)*C(4,6);...
    2*sqrt(2)*C(4,5)];
        
%% Isotropic projection
% Create isotropic projector
Iso_proj = zeros(21,21);
Iso_proj(1:3,1:3) = 3/15;
Iso_proj(4:6,4:6) = 4/15;
Iso_proj(7:9,7:9) = 1/5;
Iso_proj(1:3,7:9) = 2/15;
Iso_proj(7:9,1:3) = 2/15;
Iso_proj(1:3,4:6) = sqrt(2)/15;
Iso_proj(4:6,1:3) = sqrt(2)/15;
Iso_proj(4:6,7:9) = -sqrt(2)/15;
Iso_proj(7:9,4:6) = -sqrt(2)/15;

% Project onto isotropic space
Vec_iso = Vec_1'*Iso_proj;

% Mults is multipliers to get back to Cij values
Mults = [1,1,1,1/sqrt(2),1/sqrt(2),1/sqrt(2),1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/(2*sqrt(2)),1/(2*sqrt(2)),1/(2*sqrt(2))];
E_iso = Vec_iso.*Mults;

% Isotropic tensor
Iso_tensor = [E_iso(1) E_iso(6) E_iso(5) E_iso(10) E_iso(14) E_iso(18);
    E_iso(6) E_iso(2) E_iso(4) E_iso(16) E_iso(11) E_iso(15);
    E_iso(5) E_iso(4) E_iso(3) E_iso(13) E_iso(17) E_iso(12);
    E_iso(10) E_iso(16) E_iso(13) E_iso(7) E_iso(21) E_iso(20);
    E_iso(14) E_iso(11) E_iso(17) E_iso(21) E_iso(8) E_iso(19);
    E_iso(18) E_iso(15) E_iso(12) E_iso(20) E_iso(19) E_iso(9)];

IsoComponent(s,:) = [Iso_tensor(1,1:6) Iso_tensor(2,2:6) Iso_tensor(3,3:6) Iso_tensor(4,4:6) Iso_tensor(5,5:6) Iso_tensor(6,6)];

Vec_2 = Vec_1' - Vec_iso;

% Isotropic percent
Iso = (1-(norm(Vec_2)/norm(Vec_1)))*100; 
IsoA(btrix) = Iso;
%% Hexagonal Projection
% Create hexagonal projector
Hex_proj = zeros(21,21);
Hex_proj(1:2,1:2) = 3/8;
Hex_proj(1:2,6) = 1/(4*sqrt(2));
Hex_proj(1:2,9) = 1/4;
Hex_proj(3,3) = 1;
Hex_proj(4:5,4:5) = 1/2;
Hex_proj(6,1:2) = 1/(4*sqrt(2));
Hex_proj(6,6) = 3/4;
Hex_proj(6,9) = -1/(2*sqrt(2));
Hex_proj(7:8,7:8) = 1/2;
Hex_proj(9,1:2) = 1/4;
Hex_proj(9,6) = -1/(2*sqrt(2));
Hex_proj(9,9) = 1/2;

% Project remaining vector onto hexagonal space
Vec_Hex = Vec_2*Hex_proj;
E_Hex = Vec_Hex.*Mults;
% Hexagonal tensor
Hex_tensor = [E_Hex(1) E_Hex(6) E_Hex(5) E_Hex(10) E_Hex(14) E_Hex(18);
    E_Hex(6) E_Hex(2) E_Hex(4) E_Hex(16) E_Hex(11) E_Hex(15);
    E_Hex(5) E_Hex(4) E_Hex(3) E_Hex(13) E_Hex(17) E_Hex(12);
    E_Hex(10) E_Hex(16) E_Hex(13) E_Hex(7) E_Hex(21) E_Hex(20);
    E_Hex(14) E_Hex(11) E_Hex(17) E_Hex(21) E_Hex(8) E_Hex(19);
    E_Hex(18) E_Hex(15) E_Hex(12) E_Hex(20) E_Hex(19) E_Hex(9)];
HexagonalComponent(s,:) = [Hex_tensor(1,1:6) Hex_tensor(2,2:6) Hex_tensor(3,3:6) Hex_tensor(4,4:6) Hex_tensor(5,5:6) Hex_tensor(6,6)];
Diff(btrix) = sqrt(sum((HexagonalComponent(s,:)+IsoComponent(s,:))-SymmetryAxis(s,:)).^2);

Vec_3 = Vec_2 - Vec_Hex;

% Hexagonal percent
Hex = (1-(norm(Vec_3)/norm(Vec_2)))*(100-Iso);
HexA(btrix) = Hex;
%% Tetragonal projection
% Create tetragonal projector
Tet_proj = zeros(21,21);
Tet_proj([1,2],[1,2]) = 1/2;
Tet_proj([4,5],[4,5]) = 1/2;
Tet_proj([7,8],[7,8]) = 1/2;
Tet_proj(3,3) = 1;
Tet_proj(6,6) = 1;
Tet_proj(9,9) = 1;

% Project onto tetragonal space
Vec_Tet = Vec_3*Tet_proj;
E_Tet = Vec_Tet.*Mults;

% Tetragonal tensor
Tet_tensor = [E_Tet(1) E_Tet(6) E_Tet(5) E_Tet(10) E_Tet(14) E_Tet(18);
    E_Tet(6) E_Tet(2) E_Tet(4) E_Tet(16) E_Tet(11) E_Tet(15);
    E_Tet(5) E_Tet(4) E_Tet(3) E_Tet(13) E_Tet(17) E_Tet(12);
    E_Tet(10) E_Tet(16) E_Tet(13) E_Tet(7) E_Tet(21) E_Tet(20);
    E_Tet(14) E_Tet(11) E_Tet(17) E_Tet(21) E_Tet(8) E_Tet(19);
    E_Tet(18) E_Tet(15) E_Tet(12) E_Tet(20) E_Tet(19) E_Tet(9)];

Vec_4 = Vec_3 - Vec_Tet;

% Tetragonal percent
Tet = (1-(norm(Vec_4)/norm(Vec_3)))*(100-(Iso+Hex)); 
TetA(btrix) = Tet;
%% Orthorhombic projection

% Create orthorhombic projector
Ortho_proj = ones(21,1);
Ortho_proj([10:21]) = 0;
Ortho_proj = diag(Ortho_proj);

% Project onto orthorhombic space
Vec_Ortho = Vec_4*Ortho_proj;
E_Ortho = Vec_Ortho.*Mults;

% Orthorhombic tensor
Ortho_tensor = [E_Ortho(1) E_Ortho(6) E_Ortho(5) E_Ortho(10) E_Ortho(14) E_Ortho(18);
    E_Ortho(6) E_Ortho(2) E_Ortho(4) E_Ortho(16) E_Ortho(11) E_Ortho(15);
    E_Ortho(5) E_Ortho(4) E_Ortho(3) E_Ortho(13) E_Ortho(17) E_Ortho(12);
    E_Ortho(10) E_Ortho(16) E_Ortho(13) E_Ortho(7) E_Ortho(21) E_Ortho(20);
    E_Ortho(14) E_Ortho(11) E_Ortho(17) E_Ortho(21) E_Ortho(8) E_Ortho(19);
    E_Ortho(18) E_Ortho(15) E_Ortho(12) E_Ortho(20) E_Ortho(19) E_Ortho(9)];

Vec_5 = Vec_4 - Vec_Ortho;

% Orthorhombic percent
Ortho = (1-(norm(Vec_5)/norm(Vec_4)))*(100-(Iso+Hex+Tet));
OrthoA(btrix) = Ortho;
%% Monoclinic projection
% If all symmetry has been accounted for the norm of the remaining vector
% will be 0, and monoclinic and triclinic components will be set to 0. This
% almost never happens.
if norm(Vec_5) == 0
    Mon = 0;
    Tric = 0;
else
% Create monoclinic projector    
Mono_proj = ones(21,1);
Mono_proj([10,11,13,14,16,17,19,20]) = 0;
Mono_proj = diag(Mono_proj);

% Project onto monoclinic space
Vec_Mono = Vec_5*Mono_proj;
E_Mono = Vec_Mono.*Mults;

% Monoclinic tensor
Mono_tensor = [E_Mono(1) E_Mono(6) E_Mono(5) E_Mono(10) E_Mono(14) E_Mono(18);
    E_Mono(6) E_Mono(2) E_Mono(4) E_Mono(16) E_Mono(11) E_Mono(15);
    E_Mono(5) E_Mono(4) E_Mono(3) E_Mono(13) E_Mono(17) E_Mono(12);
    E_Mono(10) E_Mono(16) E_Mono(13) E_Mono(7) E_Mono(21) E_Mono(20);
    E_Mono(14) E_Mono(11) E_Mono(17) E_Mono(21) E_Mono(8) E_Mono(19);
    E_Mono(18) E_Mono(15) E_Mono(12) E_Mono(20) E_Mono(19) E_Mono(9)];

Vec_6 = Vec_5 - Vec_Mono;
% Monoclinic percent
Mon = (1-(norm(Vec_6)/norm(Vec_5)))*(100-(Iso+Hex+Tet+Ortho));
MonA(btrix) = Mon;
end
%% Remaining is the triclinic component
Tric = 100-(Iso+Hex+Tet+Ortho+Mon);
TricA(btrix) = Tric;
end
%% Find best Bisectrix
% Best is defined as the highest hexagonal component, and worst is defined
% as the lowest hexagonal component
[I1] = find(HexA == max(HexA(1:6)));
[I2] = find(HexA == min(HexA(1:6)));

% Put best 3 axis in 3 position, and worst 3 axis in 1 position, 2 is cross
% product of 1 and 3.
Bisectrix(:,3) = Bisectrix_All{I1(1)}(:,3);
Bisectrix(:,1) = Bisectrix_All{I2(1)}(:,3);
Bisectrix(:,2) = cross(Bisectrix(:,3),Bisectrix(:,1));

%% Run the decomposition again

%% Do basis change from x,y,z to Bisectrix. i.e. rotate into symmetry axis orientation.
Omega = Bisectrix';
K1 = Omega.^2;
for i = 1:3
    for j = 1:3
        K2(i,j) = Omega(i,round(mod(j+1,3.00001)))*Omega(i,round(mod(j+2,3.000001)));
        K3(i,j) = Omega(round(mod(i+1,3.0000001)),j)*Omega(round(mod(i+2,3.0000001)),j);
        K4(i,j) = Omega(round(mod(i+1,3.000001)),round(mod(j+1,3.000001)))*Omega(round(mod(i+2,3.000001)),round(mod(j+2,3.000001)))...
            +Omega(round(mod(i+1,3.000001)),round(mod(j+2,3.000001)))*Omega(round(mod(i+2,3.000001)),round(mod(j+1,3.000001)));
    end
end
K = [K1 2*K2; K3 K4];
C = K*C1*K';
SymmetryAxis(s,:) = [C(1,1:6) C(2,2:6) C(3,3:6) C(4,4:6) C(5,5:6) C(6,6)];
%% Create vector for projection decomposition
Vec_1 = [C(1,1);C(2,2);C(3,3);sqrt(2)*C(2,3);sqrt(2)*C(1,3);sqrt(2)*C(1,2);...
    2*C(4,4);2*C(5,5);2*C(6,6);2*C(1,4);2*C(2,5);2*C(3,6);2*C(3,4);2*C(1,5);...
    2*C(2,6);2*C(2,4);2*C(3,5);2*C(1,6);2*sqrt(2)*C(5,6);2*sqrt(2)*C(4,6);...
    2*sqrt(2)*C(4,5)];
        
%% Isotropic projection
% Create isotropic projector
Iso_proj = zeros(21,21);
Iso_proj(1:3,1:3) = 3/15;
Iso_proj(4:6,4:6) = 4/15;
Iso_proj(7:9,7:9) = 1/5;
Iso_proj(1:3,7:9) = 2/15;
Iso_proj(7:9,1:3) = 2/15;
Iso_proj(1:3,4:6) = sqrt(2)/15;
Iso_proj(4:6,1:3) = sqrt(2)/15;
Iso_proj(4:6,7:9) = -sqrt(2)/15;
Iso_proj(7:9,4:6) = -sqrt(2)/15;

% Project onto isotropic space
Vec_iso = Vec_1'*Iso_proj;
% Mults is multipliers to get back to Cij values
Mults = [1,1,1,1/sqrt(2),1/sqrt(2),1/sqrt(2),1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/(2*sqrt(2)),1/(2*sqrt(2)),1/(2*sqrt(2))];

E_iso = Vec_iso.*Mults;
% Isotropic tensor
Iso_tensor = [E_iso(1) E_iso(6) E_iso(5) E_iso(10) E_iso(14) E_iso(18);
    E_iso(6) E_iso(2) E_iso(4) E_iso(16) E_iso(11) E_iso(15);
    E_iso(5) E_iso(4) E_iso(3) E_iso(13) E_iso(17) E_iso(12);
    E_iso(10) E_iso(16) E_iso(13) E_iso(7) E_iso(21) E_iso(20);
    E_iso(14) E_iso(11) E_iso(17) E_iso(21) E_iso(8) E_iso(19);
    E_iso(18) E_iso(15) E_iso(12) E_iso(20) E_iso(19) E_iso(9)];

IsoComponent(s,:) = [Iso_tensor(1,1:6) Iso_tensor(2,2:6) Iso_tensor(3,3:6) Iso_tensor(4,4:6) Iso_tensor(5,5:6) Iso_tensor(6,6)];

Vec_2 = Vec_1' - Vec_iso;

% Isotropic percent
Iso = (1-(norm(Vec_2)/norm(Vec_1)))*100; 
%% Hexagonal Projection
% Create hexagonal projector
Hex_proj = zeros(21,21);
Hex_proj(1:2,1:2) = 3/8;
Hex_proj(1:2,6) = 1/(4*sqrt(2));
Hex_proj(1:2,9) = 1/4;
Hex_proj(3,3) = 1;
Hex_proj(4:5,4:5) = 1/2;
Hex_proj(6,1:2) = 1/(4*sqrt(2));
Hex_proj(6,6) = 3/4;
Hex_proj(6,9) = -1/(2*sqrt(2));
Hex_proj(7:8,7:8) = 1/2;
Hex_proj(9,1:2) = 1/4;
Hex_proj(9,6) = -1/(2*sqrt(2));
Hex_proj(9,9) = 1/2;

% Project remaining vector onto hexagonal space
Vec_Hex = Vec_2*Hex_proj;
E_Hex = Vec_Hex.*Mults;
% Hexagonal tensor
Hex_tensor = [E_Hex(1) E_Hex(6) E_Hex(5) E_Hex(10) E_Hex(14) E_Hex(18);
    E_Hex(6) E_Hex(2) E_Hex(4) E_Hex(16) E_Hex(11) E_Hex(15);
    E_Hex(5) E_Hex(4) E_Hex(3) E_Hex(13) E_Hex(17) E_Hex(12);
    E_Hex(10) E_Hex(16) E_Hex(13) E_Hex(7) E_Hex(21) E_Hex(20);
    E_Hex(14) E_Hex(11) E_Hex(17) E_Hex(21) E_Hex(8) E_Hex(19);
    E_Hex(18) E_Hex(15) E_Hex(12) E_Hex(20) E_Hex(19) E_Hex(9)];
HexagonalComponent(s,:) = [Hex_tensor(1,1:6) Hex_tensor(2,2:6) Hex_tensor(3,3:6) Hex_tensor(4,4:6) Hex_tensor(5,5:6) Hex_tensor(6,6)];

Vec_3 = Vec_2 - Vec_Hex;

% Hexagonal percent
Hex = (1-(norm(Vec_3)/norm(Vec_2)))*(100-Iso);
%% Tetragonal projection
% Create tetragonal projector
Tet_proj = zeros(21,21);
Tet_proj([1,2],[1,2]) = 1/2;
Tet_proj([4,5],[4,5]) = 1/2;
Tet_proj([7,8],[7,8]) = 1/2;
Tet_proj(3,3) = 1;
Tet_proj(6,6) = 1;
Tet_proj(9,9) = 1;

% Project onto tetragonal space
Vec_Tet = Vec_3*Tet_proj;
E_Tet = Vec_Tet.*Mults;

% Tetragonal tensor
Tet_tensor = [E_Tet(1) E_Tet(6) E_Tet(5) E_Tet(10) E_Tet(14) E_Tet(18);
    E_Tet(6) E_Tet(2) E_Tet(4) E_Tet(16) E_Tet(11) E_Tet(15);
    E_Tet(5) E_Tet(4) E_Tet(3) E_Tet(13) E_Tet(17) E_Tet(12);
    E_Tet(10) E_Tet(16) E_Tet(13) E_Tet(7) E_Tet(21) E_Tet(20);
    E_Tet(14) E_Tet(11) E_Tet(17) E_Tet(21) E_Tet(8) E_Tet(19);
    E_Tet(18) E_Tet(15) E_Tet(12) E_Tet(20) E_Tet(19) E_Tet(9)];

Vec_4 = Vec_3 - Vec_Tet;

% Tetragonal percent
Tet = (1-(norm(Vec_4)/norm(Vec_3)))*(100-(Iso+Hex)); 
%% Orthorhombic projection

% Create orthorhombic projector
Ortho_proj = ones(21,1);
Ortho_proj([10:21]) = 0;
Ortho_proj = diag(Ortho_proj);

% Project onto orthorhombic space
Vec_Ortho = Vec_4*Ortho_proj;
E_Ortho = Vec_Ortho.*Mults;

% Orthorhombic tensor
Ortho_tensor = [E_Ortho(1) E_Ortho(6) E_Ortho(5) E_Ortho(10) E_Ortho(14) E_Ortho(18);
    E_Ortho(6) E_Ortho(2) E_Ortho(4) E_Ortho(16) E_Ortho(11) E_Ortho(15);
    E_Ortho(5) E_Ortho(4) E_Ortho(3) E_Ortho(13) E_Ortho(17) E_Ortho(12);
    E_Ortho(10) E_Ortho(16) E_Ortho(13) E_Ortho(7) E_Ortho(21) E_Ortho(20);
    E_Ortho(14) E_Ortho(11) E_Ortho(17) E_Ortho(21) E_Ortho(8) E_Ortho(19);
    E_Ortho(18) E_Ortho(15) E_Ortho(12) E_Ortho(20) E_Ortho(19) E_Ortho(9)];

Vec_5 = Vec_4 - Vec_Ortho;

% Orthorhombic percent
Ortho = (1-(norm(Vec_5)/norm(Vec_4)))*(100-(Iso+Hex+Tet));
OrthorhombicComponent(s,:) = [Ortho_tensor(1,1:6) Ortho_tensor(2,2:6) Ortho_tensor(3,3:6) Ortho_tensor(4,4:6) Ortho_tensor(5,5:6) Ortho_tensor(6,6)];

%% Monoclinic projection
% If all symmetry has been accounted for the norm of the remaining vector
% will be 0, and monoclinic and triclinic components will be set to 0. This
% almost never happens.
if norm(Vec_5) == 0
    Mon = 0;
    Tric = 0;
else
% Create monoclinic projector    
Mono_proj = ones(21,1);
Mono_proj([10,11,13,14,16,17,19,20]) = 0;
Mono_proj = diag(Mono_proj);

% Project onto monoclinic space
Vec_Mono = Vec_5*Mono_proj;
E_Mono = Vec_Mono.*Mults;

% Monoclinic tensor
Mono_tensor = [E_Mono(1) E_Mono(6) E_Mono(5) E_Mono(10) E_Mono(14) E_Mono(18);
    E_Mono(6) E_Mono(2) E_Mono(4) E_Mono(16) E_Mono(11) E_Mono(15);
    E_Mono(5) E_Mono(4) E_Mono(3) E_Mono(13) E_Mono(17) E_Mono(12);
    E_Mono(10) E_Mono(16) E_Mono(13) E_Mono(7) E_Mono(21) E_Mono(20);
    E_Mono(14) E_Mono(11) E_Mono(17) E_Mono(21) E_Mono(8) E_Mono(19);
    E_Mono(18) E_Mono(15) E_Mono(12) E_Mono(20) E_Mono(19) E_Mono(9)];

Vec_6 = Vec_5 - Vec_Mono;
% Monoclinic percent
Mon = (1-(norm(Vec_6)/norm(Vec_5)))*(100-(Iso+Hex+Tet+Ortho));
end
%% remaining is the triclinic component
Tric = 100-(Iso+Hex+Tet+Ortho+Mon);

%% Calculate parameters of the hexagonal component tensor

Love_A = Iso_tensor(1,1) + Hex_tensor(1,1);
Love_C = Iso_tensor(3,3) + Hex_tensor(3,3);
Love_F = Iso_tensor(2,3) + Hex_tensor(2,3);
Love_L = Iso_tensor(4,4) + Hex_tensor(4,4);
Love_N = Iso_tensor(6,6) + Hex_tensor(6,6);

ACFLN = [Love_A,Love_C,Love_F,Love_L,Love_N];

% this relates the Love parameters to the Backus parameters
Trix = [1 -1 1 0 0; 1 1 1 0 0; 1 0 -3 -2 -2; 0 0 0 1 1; 0 0 0 1 -1];

Backus = inv(Trix)*ACFLN';

% etaK is Kawakatsu's ellipticity parameter, eta is the standard eta
EtaK = (Love_F + Love_L)/(sqrt(Love_A-Love_L)*sqrt(Love_C-Love_L));
Eta = Love_F/(Love_A-2*Love_L);

% Add line to Breakdown table
Line = [Iso Hex Ortho Tet Mon Tric 0 0 Backus' Love_A Love_C Love_F Love_L Love_N Eta EtaK Eigs2' Bisectrix(:,1)' Bisectrix(:,2)' Bisectrix(:,3)'];
Breakdown(s,:) = Line;

end
%% I usually write a file with the symmetry breakdown table. 
% This is useful for when you do a batch run of samples. Just un-comment
% and change filename if you want to do that.
fopen('BreakdownTest.txt','w' )
fopen('SymmetryViewTest.txt','w' )
fopen('IsotropicComponentsTest.txt','w' )
fopen('HexagonalComponentsTest.txt','w' )


dlmwrite('BreakdownTest.txt',Breakdown,'delimiter','\t','precision',4)
dlmwrite('SymmetryViewTest.txt',SymmetryAxis,'\t');
dlmwrite('IsotropicComponentsTest.txt',IsoComponent,'\t');
dlmwrite('HexagonalComponentsTest.txt',IsoComponent+HexagonalComponent,'\t');
dlmwrite('OrthorhombicComponentsTest.txt', OrthorhombicComponent, '\t');
end

