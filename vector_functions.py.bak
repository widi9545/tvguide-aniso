import os 
import numpy as np
import math
import statistics as stats
import pandas as pd
import plotly as plt
import plotly.figure_factory as ff
import scipy as sp
import math
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_table
from plotly.subplots import make_subplots
import plotly.graph_objects as go
from plotly.figure_factory import create_quiver
from scipy import interpolate
from scipy import linalg
from scipy import spatial
from iteration_utilities import flatten
from iteration_utilities import deepflatten
import ChristoffelDevParams
np.set_printoptions(threshold=np.inf)
import warnings
warnings.filterwarnings('ignore')

np.seterr(divide='ignore', invalid='ignore')


def calculate_tensor_symmetries(tensor_index, user_input=False, plotType='None', plotType3D='None'):
    christoffelParameters = ChristoffelDevParams.ChristoffelParameters()
    Res = 3
    pi = math.pi
    aggTensorColumns = christoffelParameters.columnNamesTensorCSV
    sphereColumnNames = [x for x in range(0, 121)]
    csv_tensor_number = [x for x in range(0, 50)]
    user_tensor_number = [x for x in range(97, 147)]
    user_to_csv_mapping = zip(user_tensor_number, csv_tensor_number)
    user_to_csv_mapping = dict(user_to_csv_mapping)

    #aggTensorCSVLocation = 'NSFProject/AllAggTensorsCSV.csv'
    aggTensorCSVLocation = 'tensor_scripts_info/DB_Tensors_Rhos_OrigOrientation_CSV.csv'
    if user_input==True:
        aggTensorCSVLocation = 'tensor_scripts_info/user_input.csv'
    sampleN = 1
    VRHNumber = 1
    C = []

    minNum = christoffelParameters.minNum
    Samps = 3

    tensorDF = pd.read_csv(aggTensorCSVLocation, sep=',', engine='python')
    FigName = 'Sample {} Phase={} VRH = {}'.format(str(sampleN), str(minNum), str(VRHNumber))

    #print(aggTensorCSVLocation)
    tensorIndex = int(tensor_index)
    #print(tensorDF)
    ### MAP VALUES TO DICTIONARY VALUES SO THAT IT MAPS PROPERLY - USER INPUT ILOC IS 0,1...N instead of 97...N
    #print(tensorDF.iloc[1, 4:25])
    if user_input == True:
        tensorIndex = user_to_csv_mapping[tensorIndex]
        print('this is before going through the tensor indexes', tensorIndex)
        tensorList = (tensorDF.iloc[tensorIndex, 4:25])
    else:
        tensorList = (tensorDF.iloc[tensorIndex-1, 4:25])

    Rhos = (tensorDF.iloc[tensorIndex, 3])
    print(Rhos)

    C = [[tensorList[0],tensorList[1],tensorList[2],tensorList[3],tensorList[4],tensorList[5]],
             [tensorList[1],tensorList[6],tensorList[7],tensorList[8],tensorList[9],tensorList[10]],
             [tensorList[2],tensorList[7],tensorList[11],tensorList[12],tensorList[13],tensorList[14]],
             [tensorList[3],tensorList[8],tensorList[12],tensorList[15],tensorList[16],tensorList[17]],
             [tensorList[4],tensorList[9],tensorList[13],tensorList[16],tensorList[18],tensorList[19]],
             [tensorList[5],tensorList[10],tensorList[14],tensorList[17],tensorList[19],tensorList[20]]
             ]

    C = np.asarray(C)

    voigtIndices = [[1,6,5], [6,2,4], [5,4,3]]

    Voigt_ijkl = pd.DataFrame(data=voigtIndices)
    Voigt_ijkl = Voigt_ijkl.to_numpy()

    rho = Rhos

    Xx = pd.read_csv('NSFProject/xx.csv', names=sphereColumnNames, sep=',', engine='python')
    Yy = pd.read_csv('NSFProject/yy.csv', names=sphereColumnNames, sep=',', engine='python')
    Zz = pd.read_csv('NSFProject/zz.csv', names=sphereColumnNames, sep=',', engine='python')

    Xx = Xx.fillna(0)
    Yy = Yy.fillna(0)
    Zz = Zz.fillna(0)


    Xx = Xx.to_numpy()
    Yy = Yy.to_numpy()
    Zz = Zz.to_numpy()


    test1 = 0
    test2 = 0

    m = 0
    n = 0

    T = np.zeros((3,3), dtype=float)
    TT = np.zeros((3,3), dtype=float)
    velp = np.zeros((121,121), dtype=float)
    vels1 = np.zeros((121,121), dtype=float)
    vels2 = np.zeros((121,121), dtype=float)

    VpPolxyz = np.zeros((121,121,3), dtype=float)
    Vs1Polxyz = np.zeros((121,121,3), dtype=float)
    Vs2Polxyz = np.zeros((121,121,3), dtype=float)

    eigenVecs = 0
    eigenVals = 0
    for phi in range(0, len(Xx)):

        phi_index = phi
        for theta in range(0, len(Xx)):
            theta_index = theta

            X = np.array([(Xx[theta][phi]), (Yy[theta][phi]), (Zz[theta][phi])], dtype=float)
            for i in range(0,3):
                for k in range(0,3):
                    T[i,k] = 0.0
                    for j in range(0,3):
                        for l in range(0,3):

                            m = Voigt_ijkl[i][j]
                            n = Voigt_ijkl[k][l]
                            T[i,k] = T[i,k] + C[m-1,n-1] * (X[j] * X[l])

            for i in range(0,3):
                for j in range(0,3):
                    TT[i,j] = 0.0
                    for k in range(0,3):
                        TT[i,j] = TT[i,j] + T[i,k] * T[j,k]

            eigenVals, eigenVecs = (np.linalg.eig(TT))
            idx = eigenVals.argsort()
            eigenVals = eigenVals[idx]
            idx = eigenVals.argsort()[::-1]
 
            #eigenVecs = eigenVecs[:,idx]
            #eigenVecs[:, [0,1]] = eigenVecs[:,[1,0]]
        
            vels2[theta,phi] = (math.sqrt((math.sqrt(eigenVals[0]))/rho))*10
            velp[theta,phi] = (math.sqrt((math.sqrt(eigenVals[2])) / rho))*10
            vels1[theta,phi] = (math.sqrt((math.sqrt(eigenVals[1])) / rho))*10



        
            VpPolxyz[theta,phi,:] = eigenVecs[:,2].transpose()
            Vs1Polxyz[theta,phi,:] = eigenVecs[:,1].transpose()
            Vs2Polxyz[theta,phi,:] = eigenVecs[:,0].transpose()

    

    ### velp, vels1, and vels2 are approximately correct now - what do from here? looks like velp and vels1 and vels2 get plotted without needing to do any weird interpretation


   
    Cij = C
    Sij = np.linalg.inv(Cij)
    Kvoigt = (1/9) * ((Cij[0,0] + Cij[1,1] + Cij[2,2]) + 2 * (Cij[0,1] + Cij[0,2] + Cij[1,2]))
    Kreuss =  1 / ((Sij[0,0] + Sij[1,1] + Sij[2,2]) + 2 *(Sij[0,1] + Sij[0,2] + Sij[1,2]))
    Kvrh = stats.mean([Kvoigt, Kreuss])

    Gvoigt = (1/15) * (Cij[0,0] + Cij[1,1] + Cij[2,2] + 3*(Cij[3,3] + Cij[4,4] + Cij[5,5]) - Cij[0,1] - Cij[0,2] - Cij[1,2])
    Greuss = 15 / (4 * (Sij[0,0] + Sij[1,1] + Sij[2,2] - Sij[0,1] - Sij[0,2] - Sij[1,2]) + 3 *(Sij[3,3]+Sij[4,4] + Sij[5,5]))
    Gvrh = stats.mean([Gvoigt, Greuss])

    VpIso = (((Kvrh+(4/3) * Gvrh) / (rho))**0.5) * 10
    #print(VpIso)
    VsIso = ((Gvrh/rho)**(0.5)) * 10
    VpVsIso = VpIso/VsIso

    ### time to begin plotting
    cmap1 = [[0.0, 1.0, 0.25, 0.0], [0.49,1.0,1.0, 0.0], [0.5, 0.5, 1.0,1.0],[0.51, 0.0, 1.0, 1.0],[1.0,0.5,0.0,1.0]]
    cmapA = [[0, 1, 1, 1],[0.0025, 1, 0.25, 0],[0.49, 1, 1,0],[0.5, 0.5, 1,1],[0.51, 0, 1,1],[1,0.5,0,1]]
    cmap = np.zeros((64,3), dtype=float)
    cmap2 = np.zeros((64,3), dtype=float)
    CMPTS = np.transpose(np.linspace(0.0,1.0, num=64, dtype=float))
    CMPTS2 = np.transpose(np.linspace(0.0,1.0, num=64, dtype=float))


    cmap1 = np.asarray(cmap1, dtype=float)
    cmapA = np.asarray(cmapA, dtype=float)
    f = 0


    #interp1d in scipy creates a function
    #we then need to evaluate that function as opposed to putting in a linspace where that function will be evaluted
    #for us 
    for i in range(0,3):
        interpval = interpolate.interp1d(cmap1[:,0], cmap1[:,i+1])
        interpval2 = interpolate.interp1d(cmapA[:,0], cmapA[:,i+1])
        cmap[:,i] = interpval(CMPTS)
        cmap2[:,i] = interpval2(CMPTS2)

    #### QUIVER PLOT
    NumQs = Res
    VpPol1 = np.zeros((41,41,3), dtype=float)
    VsPol1 = np.zeros((41,41,3), dtype=float)
    XxPol = np.zeros((41,41), dtype=float)
    YyPol = np.zeros((41,41), dtype=float)
    ZzPol1 = np.zeros((41,41), dtype=float)

    #this was awful
    VpPol1 = VpPolxyz[0:len(VpPolxyz):NumQs,0:len(VpPolxyz):NumQs,:]
    Vs1Pol1 = Vs1Polxyz[0:len(Vs1Polxyz):NumQs,0:len(Vs1Polxyz):NumQs,:]
    XxPol = Xx[0:len(Xx):NumQs, 0:len(Xx):NumQs]
    YyPol = Yy[0:len(Yy):NumQs, 0:len(Yy):NumQs]
    ZzPol = Zz[0:len(Zz):NumQs, 0:len(Zz):NumQs]

    Vs1PolX = Vs1Pol1[:,:,0]
    Vs1PolY = Vs1Pol1[:,:,1]
    Vs1PolZ = Vs1Pol1[:,:,2]
    #print(Vs1PolX)
    #print(np.shape(Vs1PolX))


    px = np.arange(pi*-1, pi, pi/180)
    px = np.append(px,pi)
    px = [math.cos(x) for x in px]



    py = np.arange(pi*-1, pi, pi/180)

    py = np.append(py,pi)
    py = [math.sin(y) for y in py]



    px = np.transpose(px)
    py = np.transpose(py)

    px = np.reshape(px, (len(px),1))
    py = np.reshape(py, (len(py),1))

    oX = np.reshape(np.transpose(np.array([-1.05, -1.05, 1.05, 1.05,-1.05])), (5, 1))
    oY = np.reshape(np.transpose(np.array([0.0, 1.05, 1.05,-1.05,-1.05])), (5,1))

    Pa = np.concatenate((px,py),axis=1)
    Pb = np.concatenate((oX, oY), axis=1)

    P1 = np.concatenate((Pa, Pb))
    ##can subscript for reshape - P1.shape[0] - combine xx/yy/zzz values and reshape

    XxReshapeSize = Xx.shape[0] * Xx.shape[1]
    YyReshapeSize = Yy.shape[0] * Yy.shape[1]
    ZzReshapeSize = Zz.shape[0] * Zz.shape[1]

    vpReshapeSize = velp.shape[0] * velp.shape[1]
    vels1ReshapeSize = vels1.shape[0] * vels1.shape[1]
    vels2ReshapeSize = vels2.shape[0] * vels2.shape[1]

    ### I WANT TO DIE
    Ux = np.zeros((XxReshapeSize,1), dtype=float)
    Ux = np.append(Ux, [Xx[:,x] for x in range(0,121)])
    Ux = np.delete(Ux, slice(0, XxReshapeSize))
    Ux = np.reshape(Ux, (XxReshapeSize,1))

    Uy = np.zeros((YyReshapeSize,1), dtype=float)
    Uy = np.append(Uy, [Yy[:,x] for x in range(0,121)])
    Uy = np.delete(Uy, slice(0, YyReshapeSize))
    Uy = np.reshape(Uy, (YyReshapeSize, 1))

    Uz = np.zeros((ZzReshapeSize,1), dtype=float)
    Uz = np.append(Uz, [Zz[:,x] for x in range(0,121)])
    Uz = np.delete(Uz, slice(0, ZzReshapeSize))
    Uz = np.reshape(Uz, (ZzReshapeSize,1))

    Vp = np.zeros((vpReshapeSize,1), dtype=float)
    Vp = np.append(Vp, [velp[:,x] for x in range(0,121)])
    Vp = np.delete(Vp, slice(0, vpReshapeSize))
    Vp = np.reshape(Vp, (vpReshapeSize, 1))

    Vs1 = np.zeros((vels1ReshapeSize,1), dtype=float)
    Vs1 = np.append(Vs1, [vels1[:,x] for x in range(0,121)])
    Vs1 = np.delete(Vs1, slice(0, vels1ReshapeSize))
    Vs1 = np.reshape(Vs1, (vels1ReshapeSize,1))

    Vs2 = np.zeros((vels2ReshapeSize,1), dtype=float)
    Vs2 = np.append(Vs2, [vels2[:,x] for x in range(0,121)])
    Vs2 = np.delete(Vs2, slice(0, vels2ReshapeSize))
    Vs2 = np.reshape(Vs2, (vels2ReshapeSize,1))


    Ux = Ux.flatten()
    Uy = Uy.flatten()
    Uz = Uz.flatten()

    Ux = Ux.tolist()
    Uy = Uy.tolist()
    Uz = Uz.tolist()


    Uxyz = np.array([(Ux), (Uy), (Uz)])

    Uxyz = np.transpose(Uxyz)


    df = pd.DataFrame(data=Uxyz)
    z1indicies = (df[df[2]<1].index.values)
    Uxyz = Uxyz[z1indicies,:]
    Vp = Vp[z1indicies]
    Vs1 = Vs1[z1indicies]
    Vs2 = Vs2[z1indicies]



    x, y = np.meshgrid(np.arange(-1,1.0,0.01), np.arange(-1,1,0.01))

    xaxis = np.multiply(XxPol, np.real(np.sqrt((1/(1-ZzPol)))))
    yaxis = np.multiply(YyPol, np.real(np.sqrt((1/(1-ZzPol)))))

    vels1X= np.divide(1, vels1)
    vels2Y = np.divide(1, vels2)
    colorValues = (vels2Y-vels1X)
    bright_blue = [[0, '#7DF9FF'], [1, '#7DF9FF']]
    zero_pt = pd.Series([0])

    z1 = np.array([
    [1,1,1],
    [-1,-1,-1]
    ])
    y1 = [0, 0]
    x1 = [1,-1]

    XxPol = XxPol.flatten().tolist()
    YyPol = YyPol.flatten().tolist()
    ZzPol = ZzPol.flatten().tolist()
    Vs1PolX = Vs1PolX.flatten().tolist()
    Vs1PolY = Vs1PolY.flatten().tolist()
    Vs1PolZ = Vs1PolZ.flatten().tolist()

    xMeshInitiate, yMeshInitiate = np.arange(-1,1, 0.01), np.arange(-1,1, 0.01)

    
    if plotType == 'Quiver' and plotType3D==None:
        firstInterSet = np.multiply(Uxyz[:,0], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))

        secondInterSet = np.multiply(Uxyz[:,1], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))
        
        thirdInterSet = np.divide(1, Vs2) - np.divide(1, Vs1)

        xTest = yTest = np.linspace(-1,1,len(firstInterSet))
        xTest, yTest = np.meshgrid(xMeshInitiate, yMeshInitiate)


    
        points = [firstInterSet.tolist(), secondInterSet.tolist()]
        values = [thirdInterSet.tolist()]
    
        data = interpolate.griddata((points[0], points[1]), values[0], (xTest, yTest), method='cubic')
    
        z_data = []
        for x in range(0, len(data)):
            combine = list(deepflatten(data[x], depth=1))
            z_data.append(combine)
        x_data = []
        combine = list(deepflatten(xTest, depth=1))
        x_data.append(combine)
        
    
        #y_data = []
        #combine = list(deepflatten(yTest, depth=1))
        #y_data.append(combine)
        y_data = np.linspace(-1,1,200)
        #print(len(x_data[0]), len(y_data), len(z_data[0]), 'this is the length of the previous values')
        #print(y_data)
        xCos = []
        for x in range(0, 40000):
            xCos.append(math.cos(math.radians(x)))
        ySin = []
        for y in range(0, 200):
            ySin.append(math.sin(math.radians(y)))
        # print(len(xCos), len(ySin), len(z_data), 'this is the length of the degree values')
        #print(ySin)




 
        fig = ff.create_quiver(XxPol, YyPol, Vs1PolX, Vs1PolY)
        fig.update_traces(name='Polarization Vectors', visible='legendonly')
        fig.update_layout(legend=dict(
            yanchor="top",
            xanchor="left",
            y=0.99,
            x=0.01,
        ))
        fig.add_trace(go.Contour(x=x_data[0], y=y_data, z=z_data, line_smoothing=1, showscale=True,  contours_coloring='heatmap',
            colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]
        ))
        fig.update_layout(
            yaxis=dict(range=[-2,2]),
            xaxis=dict(range=[-2,2]), 
            showlegend=True,
            height=1000,
            modebar_add='drawclosedpath',
            newshape=dict(fillcolor='turquoise'),
            plot_bgcolor='rgba(0,0,0,0)',
            title={
                'text': 'VS1 Polarization and Splitting Time (s/km)',
                'xanchor':'center',
                'yanchor':'top',
                'x': 0.5,
                'y': 0.9
            }
            )

        fig.add_trace(
            go.Scatter(
            mode='markers',
            x=[0],
            y=[0],
            marker_symbol='circle-open',
            showlegend=False, 
            marker_size=596,
            marker_line_width=192,
            opacity=1.0,
            marker_line_color='white',
            marker_color='white',
            hoverinfo='skip'
         )
        )



        return fig


    if plotType == 'VP' and plotType3D==None:

        firstInterSet = np.multiply(Uxyz[:,0], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))

        secondInterSet = np.multiply(Uxyz[:,1], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))
   
        thirdInterSet = Vp
        
        xTest = yTest = np.linspace(-1,1,len(firstInterSet))
        xTest, yTest = np.meshgrid(xMeshInitiate, yMeshInitiate)
        print()
        print('in VP')
        ### we need to use the actual VP/velp value in this, we are not for some reason - so what is happening? what can we use? 5/3/2023


    
        points = [firstInterSet.tolist(), secondInterSet.tolist()]
        values = [thirdInterSet.tolist()]
    
        data = interpolate.griddata((points[0], points[1]), values[0], (xTest, yTest), method='nearest')
        print(data)
    
        z_data = []
        for x in range(0, len(data)):
            combine = list(deepflatten(data[x], depth=1))
            z_data.append(combine)
        x_data = []
        combine = list(deepflatten(xTest, depth=1))
        x_data.append(combine)

        y_data = np.linspace(-1,1,200)
        print(len(z_data))
        

        fig = go.Figure()
        fig.add_trace(go.Contour(x=x_data[0], y=y_data, z=z_data, line_smoothing=1, showscale=True, contours_coloring='heatmap',
            colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]
        ))
        


        fig.update_layout(
            yaxis=dict(range=[-2,2]),
            xaxis=dict(range=[-2,2]), 
            showlegend=True,
            height=1000,
            title={
                'text': 'VP',
                'xanchor':'center',
                'yanchor':'top',
                'x': 0.5,
                'y': 0.9
            }
            )
        #fig.update_xaxes(domain=(0.25, 0.75))
        #fig.update_yaxes(domain=(0.25, 0.75))

        fig.update_layout(dragmode='drawrect',
                    # style of new shapes
                    newshape=dict(line_color='yellow',
                                fillcolor='turquoise',
                                opacity=0.5),
                    plot_bgcolor='rgba(0,0,0,0)')


        fig.add_trace(
            go.Scatter(
            mode='markers',
            x=[0],
            y=[0],
            marker_symbol='circle-open',
            showlegend=False, 
            marker_size=596,
            marker_line_width=194,
            opacity=1.0,
            marker_line_color='white',
            marker_color='white',
            hoverinfo='skip'

         )
        )


                            
        return fig


    if plotType == 'VS1' and plotType3D==None:
        print('in VS1')
        firstInterSet = np.multiply(Uxyz[:,0], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))

        secondInterSet = np.multiply(Uxyz[:,1], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))
   
        thirdInterSet = Vs1

        xTest = yTest = np.linspace(-1,1,len(firstInterSet))
        xTest, yTest = np.meshgrid(xMeshInitiate, yMeshInitiate)

        points = [firstInterSet.tolist(), secondInterSet.tolist()]
        values = [thirdInterSet.tolist()]
    
        data = interpolate.griddata((points[0], points[1]), values[0], (xTest, yTest), method='cubic')
    
        z_data = []
        for x in range(0, len(data)):
            combine = list(deepflatten(data[x], depth=1))
            z_data.append(combine)
        x_data = []
        combine = list(deepflatten(xTest, depth=1))
        x_data.append(combine)
    
        #y_data = []
        #combine = list(deepflatten(yTest, depth=1))
        #y_data.append(combine)
        y_data = np.linspace(-1,1,200)
        
        #fig = ff.create_quiver(XxPol, YyPol, Vs1PolX, Vs1PolY)
        fig = go.Figure()
        fig.add_trace(go.Contour(x=x_data[0], y=y_data, z=z_data, line_smoothing=1,  showscale=True, contours_coloring='heatmap',
            colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]
        ))

        fig.update_layout(
            yaxis=dict(range=[-2,2]),
            xaxis=dict(range=[-2,2]), 
            showlegend=True,
            height=1000,
            plot_bgcolor='rgba(0,0,0,0)',
            title={
                'text': 'VS1',
                'xanchor':'center',
                'yanchor':'top',
                'x': 0.5,
                'y': 0.9
            }
            )


        fig.add_trace(
            go.Scatter(
            mode='markers',
            x=[0],
            y=[0],
            marker_symbol='circle-open',
            showlegend=False, 
            marker_size=596,
            marker_line_width=192,
            opacity=1.0,
            marker_line_color='white',
            marker_color='white',
            hoverinfo='skip'
         )
        )

        return fig
 

    if plotType == 'VS2' and plotType3D==None:
        firstInterSet = np.multiply(Uxyz[:,0], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))

        secondInterSet = np.multiply(Uxyz[:,1], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))
   
        thirdInterSet = Vs2
        xTest = yTest = np.linspace(-1,1,len(firstInterSet))
        xTest, yTest = np.meshgrid(xMeshInitiate, yMeshInitiate)

        points = [firstInterSet.tolist(), secondInterSet.tolist()]
        values = [thirdInterSet.tolist()]
    
        data = interpolate.griddata((points[0], points[1]), values[0], (xTest, yTest), method='cubic')
    
        z_data = []
        for x in range(0, len(data)):
            combine = list(deepflatten(data[x], depth=1))
            z_data.append(combine)
        x_data = []
        combine = list(deepflatten(xTest, depth=1))
        x_data.append(combine)
    
        #y_data = []
        #combine = list(deepflatten(yTest, depth=1))
        #y_data.append(combine)
        y_data = np.linspace(-1,1,200)
        
        #fig = ff.create_quiver(XxPol, YyPol, Vs1PolX, Vs1PolY)
        fig = go.Figure()
        fig.add_trace(go.Contour(x=x_data[0], y=y_data, z=z_data, line_smoothing=1,  showscale=True, contours_coloring='heatmap',
            colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]
        ))
        

        fig.update_layout(
            yaxis=dict(range=[-2,2]),
            xaxis=dict(range=[-2,2]), 
            showlegend=True,
            height=1000,
            plot_bgcolor='rgba(0,0,0,0)',
            title={
                'text': 'VS2',
                'xanchor':'center',
                'yanchor':'top',
                'x': 0.5,
                'y': 0.9
            }
            )


        fig.add_trace(
            go.Scatter(
            mode='markers',
            x=[0],
            y=[0],
            marker_symbol='circle-open',
            showlegend=False, 
            marker_size=596,
            marker_line_width=194,
            opacity=1.0,
            marker_line_color='white',
            marker_color='white',
            hoverinfo='skip'
         )
        )



        
        return fig

    if plotType == 'VPVS1' and plotType3D==None:

        print('we are in VPVS1')
        firstInterSet = np.multiply(Uxyz[:,0], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))

        secondInterSet = np.multiply(Uxyz[:,1], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))
   
        thirdInterSet = Vp/Vs1
        xTest = yTest = np.linspace(-1,1,len(firstInterSet))
        xTest, yTest = np.meshgrid(xMeshInitiate, yMeshInitiate)

        points = [firstInterSet.tolist(), secondInterSet.tolist()]
        values = [thirdInterSet.tolist()]
    
        data = interpolate.griddata((points[0], points[1]), values[0], (xTest, yTest), method='cubic')
    
        z_data = []
        for x in range(0, len(data)):
            combine = list(deepflatten(data[x], depth=1))
            z_data.append(combine)
        x_data = []
        combine = list(deepflatten(xTest, depth=1))
        x_data.append(combine)
    
        #y_data = []
        #combine = list(deepflatten(yTest, depth=1))
        #y_data.append(combine)
        y_data = np.linspace(-1,1,200)
        
        #fig = ff.create_quiver(XxPol, YyPol, Vs1PolX, Vs1PolY)
        fig = go.Figure()
        fig.add_trace(go.Contour(x=x_data[0], y=y_data, z=z_data, line_smoothing=1, zmin=1.73, zmax=1.79,  showscale=True, contours_coloring='heatmap',
            colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]
        ))
        

        fig.update_layout(
            yaxis=dict(range=[-2,2]),
            xaxis=dict(range=[-2,2]), 
            showlegend=True,
            height=1000,
            plot_bgcolor='rgba(0,0,0,0)',
            title={
                'text': 'VPVS1',
                'xanchor':'center',
                'yanchor':'top',
                'x': 0.5,
                'y': 0.9
            }
            )
        fig.add_trace(
            go.Scatter(
            mode='markers',
            x=[0],
            y=[0],
            marker_symbol='circle-open',
            showlegend=False, 
            marker_size=596,
            marker_line_width=194,
            opacity=1.0,
            marker_line_color='white',
            marker_color='white',
            hoverinfo='skip'
         )
        )




        
        return fig


    df = pd.DataFrame(list(zip(XxPol, YyPol, ZzPol, Vs1PolX, Vs1PolY, Vs1PolZ)), columns = ['x','y','z','u','v','w'])
    np.random.seed(20)
    remove_n = 1300
    drop_indices = np.random.choice(df.index, remove_n, replace=False)
    df = df.drop(drop_indices)
    index_list = df.index

      
    #print(colorValues)
    if plotType3D=='3DQuiver' and plotType==None:

        fig1 = make_subplots(rows=1, cols=1,
                            specs=[[{'is_3d': True}]],
                            subplot_titles=['Vs1 Polarization & splitting time (s/km)'],
                        )

        fig1.add_trace(go.Surface(x=Xx, y=Yy, z=Zz, surfacecolor=colorValues, showscale=False, 
                colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]    
        ))
        fig1.add_trace(go.Surface(z=z1, y=y1, x=x1, showscale=False))
        for t in index_list:
            fig1.add_trace(go.Cone(x=[df['x'][t]],y=[df['y'][t]],z=[df['z'][t]],u=[df['u'][t]],w=[df['w'][t]],v=[df['v'][t]], colorscale='Blues', showscale=False, sizemode='absolute', sizeref=0.15))
        
        fig1.update_layout(scene_camera_eye=dict(x=-0.76, y=1.8, z=0.92))
        fig1.update_layout(
            scene=dict(
            xaxis= dict(nticks=1, range=[-1,1], visible=False,),
            yaxis= dict(nticks=1, range=[-1,1], visible=False,),
            zaxis= dict(nticks=1, range=[-1,1], visible=False,),)
        )
        return fig1


        
    if plotType3D=='3DVP' and plotType==None:
        vpFig = make_subplots(rows=1, cols=1,
                        specs=[[{'is_3d': True}]],
                        subplot_titles=['VP (km/s)'],
                     )
        vpFig.add_trace(go.Surface(x=Xx, y=Yy, z=Zz, surfacecolor=velp*2.5,
                colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]
         ), 1, 1)
        #vpFig.add_trace(go.Surface(z=z1, y=y1, x=x1, showscale=False))
        vpFig.update_layout(
            scene=dict(
            xaxis= dict(nticks=5, range=[-1,1], visible=False,),
            yaxis= dict(nticks=5, range=[-1,1], visible=False,),
            zaxis= dict(nticks=5, range=[-1,1], visible=False,),)
        )
        return vpFig

    if plotType3D=='3DVS1' and plotType==None:
        vs1Fig = make_subplots(rows=1, cols=1,
                          specs=[[{'is_3d': True}]],
                          subplot_titles=['Vs1 (km/s)'],
                     )
        vs1Fig.add_trace(go.Surface(x=Xx, y=Yy, z=Zz, surfacecolor=vels1*4,
                colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]
        
        ), 1, 1)
        vs1Fig.add_trace(go.Surface(z=z1, y=y1, x=x1, showscale=False))
        vs1Fig.update_layout(
            scene=dict(
            xaxis= dict(nticks=5, range=[-1,1], visible=False,),
            yaxis= dict(nticks=5, range=[-1,1], visible=False,),
            zaxis= dict(nticks=5, range=[-1,1], visible=False,),)
        )
        return vs1Fig

    if plotType3D=='3DVS2' and plotType==None:
        vs2Fig = make_subplots(rows=1, cols=1,
                            specs=[[{'is_3d': True}]],
                            subplot_titles=['Vs2 (km/s)'],
                       )
        vs2Fig.add_trace(go.Surface(x=Xx, y=Yy, z=Zz, surfacecolor=vels2*4,
                colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]
        
        ), 1, 1)
        vs2Fig.add_trace(go.Surface(z=z1, y=y1, x=x1, showscale=False))
        vs2Fig.update_layout(
            scene=dict(
            xaxis= dict(nticks=5, range=[-1,1], visible=False,),
            yaxis= dict(nticks=5, range=[-1,1], visible=False,),
            zaxis= dict(nticks=5, range=[-1,1], visible=False,),)
        )
        return vs2Fig
    if plotType3D=='3DVPVS1' and plotType==None:
    
        vpvs1 = np.divide(velp, vels1)

        vpvs1Fig = make_subplots(rows=1, cols=1,
                        specs=[[{'is_3d': True}]],
                        subplot_titles=['VP/VS1 (km/s)'],
                    )
        vpvs1Fig.add_trace(go.Surface(x=Xx, y=Yy, z=Zz, surfacecolor=vpvs1, 
                colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]), 1, 1)
                
        vpvs1Fig.add_trace(go.Surface(z=z1, y=y1, x=x1, showscale=False))
        vpvs1Fig.update_layout(
            scene=dict(
            xaxis= dict(nticks=5, range=[-1,1], visible=False,),
            yaxis= dict(nticks=5, range=[-1,1], visible=False,),
            zaxis= dict(nticks=5, range=[-1,1], visible=False,),)
        )

        return vpvs1Fig


    if plotType == 'Back Azimuthal Plot':
        print('in function')
        VpPolX = VpPol1[:,:,0]
        VpPolY = VpPol1[:,:,1]
        VpPolZ = VpPol1[:,:,2]


        return fig


def tv_fold_model(tensor_index, user_input=False, plotType='None'):

    christoffelParameters = ChristoffelDevParams.ChristoffelParameters()

    pi = math.pi
    user_input = False
    tensor_index=1

    aggTensorColumns = christoffelParameters.columnNamesTensorCSV
    sphereColumnNames = [x for x in range(0, 121)]
    csv_tensor_number = [x for x in range(0, 50)]
    user_tensor_number = [x for x in range(97, 147)]
    Res = 100

    user_to_csv_mapping = zip(user_tensor_number, csv_tensor_number)
    user_to_csv_mapping = dict(user_to_csv_mapping)


    aggTensorCSVLocation = 'tensor_scripts_info/DB_Tensors_Rhos_OrigOrientation_CSV.csv'
    if user_input==True:
        aggTensorCSVLocation = 'tensor_scripts_info/user_input.csv'

    C = []

    tensorDF = pd.read_csv(aggTensorCSVLocation, sep=',', engine='python')


    tensorIndex = int(tensor_index)
    #print(tensorIndex)

    if user_input == False:
        tensorList = (tensorDF.iloc[tensorIndex-1, 3:24])
    if user_input == True:
        tensorIndex = user_to_csv_mapping[tensorIndex]
        print('this is before going throug the tensor indexes', tensorIndex)
        tensorList = (tensorDF.iloc[tensorIndex, 4:25])


    C = [[tensorList[0],tensorList[1],tensorList[2],tensorList[3],tensorList[4],tensorList[5]],
             [tensorList[1], tensorList[6], tensorList[7], tensorList[8],tensorList[9],tensorList[10]],
             [tensorList[2],tensorList[7],tensorList[11],tensorList[12],tensorList[13],tensorList[14]],
             [tensorList[3],tensorList[8],tensorList[12],tensorList[15],tensorList[16],tensorList[17]],
             [tensorList[4],tensorList[9],tensorList[13],tensorList[16],tensorList[18],tensorList[19]],
             [tensorList[5],tensorList[10],tensorList[14],tensorList[17],tensorList[19],tensorList[20]]
             ]

    
    C = np.asarray(C)



    rho = 8
    Ang = []
    for ang in range(-180,181):
        Ang.append(ang)
    Amp = 25
    Per = 4
    ResN= 100
    Shape = [] 
    for x in Ang:
        Shape.append(Amp*math.sin(math.radians(Per*x)))
    TLoc = np.linspace(1, len(Ang)-1 ,ResN)
    TLoc = np.round(TLoc)

    diff = np.diff(Shape)
    dip_staging = -1*np.degrees(np.arctan(diff))
    dip = []

    for x in TLoc:
        dip.append(dip_staging[int(x)-1])
    RotatedCij = np.zeros((100,22))

    rake = np.zeros((100,1))
    
    trend = np.zeros((100,1))
    SL = 0
    L1 = 0
    L2 = 0 

    
    strike = np.zeros((100,1))
    for x in range(0, len(trend)):
        trend[x] = 90
    
    for i in range(0, len(dip)):
        if (trend[i] - strike[i]) == 180:
            rake[i] = 180
        elif trend[i] < strike[i]:
            trend[i] = trend[i] + 360
        if dip[i] == 0:
            rake[i] = trend[i]
        else:
            SL = np.cos(np.deg2rad(trend[i]-strike[i]))
            L1 = np.sin(np.deg2rad(trend[i]-strike[i]))
            L2 = L1 / np.cos(np.deg2rad(dip[i]))
            rake[i] = np.degrees(np.arctan(L2/SL))
            if rake[i] < 0:
                rake[i] = 180 + rake[i]
        rake[i] = -1*rake[i]
    ya = []
    xa = []
    za = []
    yrake = []
    for i in range(0, len(dip)):
        ya.append(dip[i])
        xa.append(0)
        za.append(strike[i])
        yrake.append(rake[i]-90)
    for s in range(0, len(dip)):
        zr = float(-1*za[s]*((math.pi)/180))
        xr = float(-1*xa[s]*((math.pi)/180))
        yr = float(ya[s]*((math.pi)/180))
        yrk = float((1*yrake[s])*((math.pi)/180))

        Rx = [[1,0,0,0,0,0], 
        [0, np.cos(xr)**2, np.sin(xr)**2, 2*np.cos(xr)*np.sin(xr), 0, 0], 
        [0, np.sin(xr)**2, np.cos(xr)**2, -2*np.sin(xr)*np.cos(xr), 0, 0], 
        [0, -np.cos(xr)*np.sin(xr), np.cos(xr)*np.sin(xr), (np.cos(xr)**2)-(np.sin(xr)**2),0,0],
        [0, 0, 0, 0, np.cos(xr), -np.sin(xr)],
        [0, 0, 0, 0, np.sin(xr), np.cos(xr)]
        ]


        Ry = [[np.cos(yr)**2, 0, np.sin(yr)**2, 0, 2*np.cos(yr)*np.sin(yr),0], 
        [0,1,0,0,0,0], 
        [np.sin(yr)**2, 0, np.cos(yr)**2, 0, -2*np.cos(yr)*np.sin(yr),0], 
        [0,0,0, np.cos(yr), 0, -1*np.sin(yr)],
        [-1*np.cos(yr)*np.sin(yr), 0, np.cos(yr)*np.sin(yr),0, (np.cos(yr)**2)-(np.sin(yr)**2),0],
        [0,0,0, np.sin(yr), 0, np.cos(yr)]
        ]


        Rz = [[np.cos(zr)**2, np.sin(zr)**2, 0,0,0, -2*np.cos(zr)*np.sin(zr)], 
        [np.sin(zr)**2, np.cos(zr)**2, 0,0,0, 2*np.cos(zr)*np.sin(zr)], 
        [0,0,1,0,0,0], 
        [0,0,0, np.cos(zr),np.sin(zr),0],
        [0,0,0,-1*np.sin(zr), np.cos(zr),0],
        [np.cos(zr)*np.sin(zr), -1*np.cos(zr)*np.sin(zr),0,0,0, (np.cos(zr)**2)-(np.sin(zr)**2)]
        ]
        
        
        Ryrake = [[np.cos(yrk)**2, np.sin(yrk)**2, 0,0,0, -2*(np.cos(yrk))*(np.sin(yrk))], 
        [np.sin(yrk)**2, np.cos(yrk)**2, 0, 0, 0, 2*np.cos(yrk)*np.sin(yrk)], 
        [0,0,1,0,0,0], 
        [0,0,0,np.cos(yrk),np.sin(yrk),0],
        [0,0,0, -1*np.sin(yrk), np.cos(yrk),0],
        [np.cos(yrk)*np.sin(yrk), -1*np.cos(yrk)*np.sin(yrk),0,0,0, (np.cos(yrk)**2)-(np.sin(yrk)**2)]
        ]
        


        CR = C
        CR = np.matmul(np.matmul(Ryrake, CR),np.transpose(Ryrake))
        CR = np.matmul(np.matmul(Rx, CR),np.transpose(Rx))
        CR = np.matmul(np.matmul(Ry, CR),np.transpose(Ry))
        CR = np.matmul(np.matmul(Rz, CR),np.transpose(Rz))

        RotatedCij[s][0] = 3
        RotatedCij[s][1:7] = CR[0]
        RotatedCij[s][7:12] = CR[1][1:6]
        RotatedCij[s][12:16] = CR[2][2:6]
        RotatedCij[s][16:19] = CR[3][3:6]
        RotatedCij[s][19:21] = CR[4][4:6]
        RotatedCij[s][21:23] = CR[5][5:7]

    tensorsV = []
    tensorsR = []
    #print(RotatedCij[0][1:])

    V_ave = np.zeros((36,1), dtype=float)
    R_ave = np.zeros((36,1), dtype=float)

    for array in range(0,100):
        tensorsV.append(np.zeros((6,6),dtype=float))
        tensorsR.append(np.zeros((6,6),dtype=float))
    for i in range(0,100):
        C = RotatedCij[i][1:]
        #all indicies below are subtracted by 1 for indexing purposes
        
        # second row had been C[6], C[7],C[8],C[9], C[10],C[11]
        tensorsV[i] = [[C[0], C[1], C[2], C[3], C[4], C[5]], 
        [C[1], C[6],C[7],C[8], C[9],C[10]], 
        [C[2], C[7], C[11], C[12], C[13], C[14]], 
        [C[3], C[8], C[12], C[15], C[16],C[17]],
        [C[4], C[9], C[13], C[16], C[18],C[19]],
        [C[5], C[10], C[14], C[17], C[19], C[20]]
        ]
        tensorsV[i] = np.asarray(tensorsV[i])
        
    for i in range(0,100):
        tensorsR[i] = np.linalg.pinv(tensorsV[i])

    for i in range(0,36):
        PV = np.zeros((100,1), dtype=float)
        PR = np.zeros((100,1), dtype=float)
        for j in range(0,100):
            flattenedVTensor = tensorsV[j].flatten()
            flattenedRTensor = tensorsR[j].flatten()
            PV[j,] = flattenedVTensor[i]
            PR[j,] = flattenedRTensor[i]
        V_ave[i] = np.mean(PV)
        R_ave[i] = np.mean(PR)

    


    
    test_array = np.zeros((6,6), dtype=float)

    #re-do average arrays
    
    V_ave = np.reshape(V_ave, (6,6))
    R_ave = np.reshape(R_ave, (6,6))

    #V_ave = V_ave.flatten()
    #V_ave = V_ave.tolist()
    
    #V_ave_rounded = []
    #R_ave_rounded = []

    #for x in V_ave:
        #y = round(x,4)
        #V_ave_rounded.append(y)
    VRH = (V_ave + linalg.inv(R_ave))/2

    C = np.reshape(VRH, (6,6))
    

    Res = 3
    voigtIndices = [[1,6,5], [6,2,4], [5,4,3]]

    Voigt_ijkl = pd.DataFrame(data=voigtIndices)
    Voigt_ijkl = Voigt_ijkl.to_numpy()

    Xx = pd.read_csv('NSFProject/xx.csv', names=sphereColumnNames, sep=',', engine='python')
    Yy = pd.read_csv('NSFProject/yy.csv', names=sphereColumnNames, sep=',', engine='python')
    Zz = pd.read_csv('NSFProject/zz.csv', names=sphereColumnNames, sep=',', engine='python')

    Xx = Xx.fillna(0)
    Yy = Yy.fillna(0)
    Zz = Zz.fillna(0)


    Xx = Xx.to_numpy()
    Yy = Yy.to_numpy()
    Zz = Zz.to_numpy()

    m = 0
    n = 0

    T = np.zeros((3,3), dtype=float)
    TT = np.zeros((3,3), dtype=float)
    velp = np.zeros((121,121), dtype=float)
    vels1 = np.zeros((121,121), dtype=float)
    vels2 = np.zeros((121,121), dtype=float)

    VpPolxyz = np.zeros((121,121,3), dtype=float)
    Vs1Polxyz = np.zeros((121,121,3), dtype=float)
    Vs2Polxyz = np.zeros((121,121,3), dtype=float)

    eigenVecs = 0
    eigenVals = 0



    eigenVecs = 0
    eigenVals = 0

    for phi in range(0, len(Xx)):

        phi_index = phi
        for theta in range(0, len(Xx)):
            theta_index = theta

            X = np.array([(Xx[theta][phi]), (Yy[theta][phi]), (Zz[theta][phi])], dtype=float)
            for i in range(0,3):
                for k in range(0,3):
                    T[i,k] = 0.0
                    for j in range(0,3):
                        for l in range(0,3):

                            m = Voigt_ijkl[i][j]
                            n = Voigt_ijkl[k][l]
                            #test = C[m-1,n-1] 
                            #+ C[m-1,n-1]
                            T[i,k] = T[i,k] + C[m-1,n-1] * (X[j] * X[l])
 
            for i in range(0,3):
                for j in range(0,3):
                    TT[i,j] = 0.0
                    for k in range(0,3):
                        TT[i,j] = TT[i,j] + T[i,k] * T[j,k]
            

            eigenVals, eigenVecs = (linalg.eig(TT))
            #idx = eigenVals.argsort()
            #eigenVals = eigenVals[idx]
           #idx = eigenVals.argsort()[::-1]
            #eigenVals = eigenVals.real
 
            #eigenVecs = eigenVecs[:,idx]
            #eigenVecs[:, [0,1]] = eigenVecs[:,[1,0]]
        
            #all were previously (math.sqrt(math.sqrt(eigenVals[etc]/ rho)) - gave us incorrect answers
            velp[theta,phi] = (math.sqrt(math.sqrt(eigenVals[0])/ rho))*10
            vels1[theta,phi] = (math.sqrt(math.sqrt(eigenVals[1])/ rho) * 10)
            vels2[theta,phi] = (math.sqrt(math.sqrt(eigenVals[2])/ rho) * 10)

        
            VpPolxyz[theta,phi,:] = np.transpose(eigenVecs[:,2])
            Vs1Polxyz[theta,phi,:] = np.transpose(eigenVecs[:,1])
            Vs2Polxyz[theta,phi,:] = np.transpose(eigenVecs[:,0])

    ###Isotropic Properties
    #print(np.transpose(eigenVecs[:,0]))


    Cij = C
    Sij = np.linalg.inv(Cij)
    Kvoigt = (1/9) * ((Cij[0,0] + Cij[1,1] + Cij[2,2]) + 2 * (Cij[0,1] + Cij[0,2] + Cij[1,2]))
    Kreuss =  1 / ((Sij[0,0] + Sij[1,1] + Sij[2,2]) + 2 *(Sij[0,1] + Sij[0,2] + Sij[1,2]))
    Kvrh = stats.mean([Kvoigt, Kreuss])

    Gvoigt = (1/15) * (Cij[0,0] + Cij[1,1] + Cij[2,2] + 3*(Cij[3,3] + Cij[4,4] + Cij[5,5]) - Cij[0,1] - Cij[0,2] - Cij[1,2])
    Greuss = 15 / (4 * (Sij[0,0] + Sij[1,1] + Sij[2,2] - Sij[0,1] - Sij[0,2] - Sij[1,2]) + 3 *(Sij[3,3]+Sij[4,4] + Sij[5,5]))
    Gvrh = stats.mean([Gvoigt, Greuss])

    VpIso = (((Kvrh+(4/3) * Gvrh) / (rho))**0.5) * 10
    VsIso = ((Gvrh/rho)**(0.5)) * 10
    VpVsIso = VpIso/VsIso

    #### QUIVER PLOT
    #NumQs = Res
    NumQs = 3
    VpPol1 = np.zeros((41,41,3), dtype=float)
    VsPol1 = np.zeros((41,41,3), dtype=float)
    XxPol = np.zeros((41,41), dtype=float)
    YyPol = np.zeros((41,41), dtype=float)
    ZzPol1 = np.zeros((41,41), dtype=float)
    #this was awful
    VpPol1 = VpPolxyz[0:len(VpPolxyz):NumQs,0:len(VpPolxyz):NumQs,:]
    Vs1Pol1 = Vs1Polxyz[0:len(Vs1Polxyz):NumQs,0:len(Vs1Polxyz):NumQs,:]
    XxPol = Xx[0:len(Xx):NumQs, 0:len(Xx):NumQs]
    YyPol = Yy[0:len(Yy):NumQs, 0:len(Yy):NumQs]
    ZzPol = Zz[0:len(Zz):NumQs, 0:len(Zz):NumQs]
    #print(VpPol1)


    Vs1PolX = Vs1Pol1[:,:,0]
    Vs1PolY = Vs1Pol1[:,:,1]
    Vs1PolZ = Vs1Pol1[:,:,2]




    #print(np.shape(Vs1PolX))


    px = np.arange(pi*-1, pi, pi/180)
    px = np.append(px,pi)
    px = [math.cos(x) for x in px]


    py = np.arange(pi*-1, pi, pi/180)

    py = np.append(py,pi)
    py = [math.sin(y) for y in py]



    px = np.transpose(px)
    py = np.transpose(py)

    px = np.reshape(px, (len(px),1))
    py = np.reshape(py, (len(py),1))

    oX = np.reshape(np.transpose(np.array([-1.05, -1.05, 1.05, 1.05,-1.05])), (5, 1))
    oY = np.reshape(np.transpose(np.array([0.0, 1.05, 1.05,-1.05,-1.05])), (5,1))

    Pa = np.concatenate((px,py),axis=1)
    Pb = np.concatenate((oX, oY), axis=1)

    P1 = np.concatenate((Pa, Pb))
    ##can subscript for reshape - P1.shape[0] - combine xx/yy/zzz values and reshape

    XxReshapeSize = Xx.shape[0] * Xx.shape[1]
    YyReshapeSize = Yy.shape[0] * Yy.shape[1]
    ZzReshapeSize = Zz.shape[0] * Zz.shape[1]

    vpReshapeSize = velp.shape[0] * velp.shape[1]
    vels1ReshapeSize = vels1.shape[0] * vels1.shape[1]
    vels2ReshapeSize = vels2.shape[0] * vels2.shape[1]

    ### I WANT TO DIE
    Ux = np.zeros((XxReshapeSize,1), dtype=float)
    Ux = np.append(Ux, [Xx[:,x] for x in range(0,121)])
    Ux = np.delete(Ux, slice(0, XxReshapeSize))
    Ux = np.reshape(Ux, (XxReshapeSize,1))

    Uy = np.zeros((YyReshapeSize,1), dtype=float)
    Uy = np.append(Uy, [Yy[:,x] for x in range(0,121)])
    Uy = np.delete(Uy, slice(0, YyReshapeSize))
    Uy = np.reshape(Uy, (YyReshapeSize, 1))

    Uz = np.zeros((ZzReshapeSize,1), dtype=float)
    Uz = np.append(Uz, [Zz[:,x] for x in range(0,121)])
    Uz = np.delete(Uz, slice(0, ZzReshapeSize))
    Uz = np.reshape(Uz, (ZzReshapeSize,1))

    Vp = np.zeros((vpReshapeSize,1), dtype=float)
    Vp = np.append(Vp, [velp[:,x] for x in range(0,121)])
    Vp = np.delete(Vp, slice(0, vpReshapeSize))
    Vp = np.reshape(Vp, (vpReshapeSize, 1))

    Vs1 = np.zeros((vels1ReshapeSize,1), dtype=float)
    
    Vs1 = np.append(Vs1, [vels1[:,x] for x in range(0,121)])
    
    Vs1 = np.delete(Vs1, slice(0, vels1ReshapeSize))
    Vs1 = np.reshape(Vs1, (vels1ReshapeSize,1))

    Vs2 = np.zeros((vels2ReshapeSize,1), dtype=float)
    Vs2 = np.append(Vs2, [vels2[:,x] for x in range(0,121)])
    Vs2 = np.delete(Vs2, slice(0, vels2ReshapeSize))
    Vs2 = np.reshape(Vs2, (vels2ReshapeSize,1))


    Ux = Ux.flatten()
    Uy = Uy.flatten()
    Uz = Uz.flatten()

    Ux = Ux.tolist()
    Uy = Uy.tolist()
    Uz = Uz.tolist()


    Uxyz = np.array([(Ux), (Uy), (Uz)])
    Uxyz = np.transpose(Uxyz)


    ### Min = find(Data(:,2) == MinNum);
    ### I = find(Uxyz(:,3)<1);
    #minList = (tensorDF[tensorDF['Phase']==minNum].index.values)
    df = pd.DataFrame(data=Uxyz)
    z1indicies = (df[df[2]<1].index.values)
    Uxyz = Uxyz[z1indicies,:]
    Vp = Vp[z1indicies]
    Vs1 = Vs1[z1indicies]
    Vs2 = Vs2[z1indicies]

    x, y = np.meshgrid(np.arange(-1,1.0,0.01), np.arange(-1,1,0.01))
    ### 1 - Zzpol will work
    ### (1/(1-ZzPol)) will work as well
    ### numpy.sqrt? -- will work 

    xaxis = np.multiply(XxPol, np.real(np.sqrt((1/(1-ZzPol)))))
    yaxis = np.multiply(YyPol, np.real(np.sqrt((1/(1-ZzPol)))))

    vels1X = np.divide(1, vels1)
    vels2Y = np.divide(1, vels2)
    colorValues = (vels2Y-vels1X)
    bright_blue = [[0, '#7DF9FF'], [1, '#7DF9FF']]
    zero_pt = pd.Series([0])

    z1 = np.array([
    [1,1,1],
    [-1,-1,-1]
    ])
    y1 = [0, 0]
    x1 = [1,-1]

    XxPol = XxPol.flatten().tolist()
    YyPol = YyPol.flatten().tolist()
    ZzPol = ZzPol.flatten().tolist()
    Vs1PolX = Vs1PolX.flatten().tolist()
    Vs1PolY = Vs1PolY.flatten().tolist()
    Vs1PolZ = Vs1PolZ.flatten().tolist()
    
    #test = np.array([[np.arange(-1,0.01,1)],[np.arange(-1,0.01,1)]], dtype=float)
    xMeshInitiate, yMeshInitiate = np.arange(-1,1, 0.01), np.arange(-1,1, 0.01)
    
    #xMeshInitiate = np.linspace(-1,1,201)
    #yMeshInitiate = np.linspace(-1,1,201)
    #xTest, yTest = np.meshgrid(xMeshInitiate, yMeshInitiate)

    
    uxyzCopy = Uxyz.tolist()
    

    
    ### WHAT INTERP FUNCTION TO USE

    if plotType == 'Vs1 Polarization':
        firstInterSet = np.multiply(Uxyz[:,0], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))

        secondInterSet = np.multiply(Uxyz[:,1], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))
        
        thirdInterSet = np.divide(1, Vs2) - np.divide(1, Vs1)

        xTest = yTest = np.linspace(-1,1,len(firstInterSet))
        xTest, yTest = np.meshgrid(xMeshInitiate, yMeshInitiate)


    
        points = [firstInterSet.tolist(), secondInterSet.tolist()]
        values = [thirdInterSet.tolist()]
    
        data = interpolate.griddata((points[0], points[1]), values[0], (xTest, yTest), method='cubic')
    
        z_data = []
        for x in range(0, len(data)):
            combine = list(deepflatten(data[x], depth=1))
            z_data.append(combine)
        x_data = []
        combine = list(deepflatten(xTest, depth=1))
        x_data.append(combine)
    
        #y_data = []
        #combine = list(deepflatten(yTest, depth=1))
        #y_data.append(combine)
        y_data = np.linspace(-1,1,200)
        
        fig = ff.create_quiver(XxPol, YyPol, Vs1PolX, Vs1PolY)
        fig.add_trace(go.Contour(x=x_data[0], y=y_data, z=z_data, line_smoothing=1, showscale=True,  contours_coloring='heatmap',
            colorscale=[[0.0, "rgb(49,54,149)"],
                [0.1111111111111111, "rgb(69,117,180)"],
                [0.2222222222222222, "rgb(116,173,209)"],
                [0.3333333333333333, "rgb(171,217,233)"],
                [0.4444444444444444, "rgb(224,243,248)"],
                [0.5555555555555556, "rgb(254,224,144)"],
                [0.6666666666666666, "rgb(253,174,97)"],
                [0.7777777777777778, "rgb(244,109,67)"],
                [0.8888888888888888, "rgb(215,48,39)"],
                [1.0, "rgb(165,0,38)"]]
        ))
        fig.update_layout(
            yaxis=dict(range=[-2,2]),
            xaxis=dict(range=[-2,2]), 
            showlegend=True,
            height=1000,
            modebar_add='drawclosedpath',
            newshape=dict(fillcolor='turquoise'),
            plot_bgcolor='rgba(0,0,0,0)',
            title={
                'text': 'VS1 Polarization and Splitting Time (s/km)',
                'xanchor':'center',
                'yanchor':'top',
                'x': 0.5,
                'y': 0.9
            }
            )

        fig.add_trace(
            go.Scatter(
            mode='markers',
            x=[0],
            y=[0],
            marker_symbol='circle-open',
            showlegend=False, 
            marker_size=599,
            marker_line_width=192,
            opacity=1.0,
            marker_line_color='white',
            marker_color='white',
            hoverinfo='skip'
         )
        )



        return fig


    if plotType == 'VP':
        firstInterSet = np.multiply(Uxyz[:,0], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))

        secondInterSet = np.multiply(Uxyz[:,1], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))
   
        thirdInterSet = Vp
        
        xTest = yTest = np.linspace(-1,1,len(firstInterSet))
        xTest, yTest = np.meshgrid(xMeshInitiate, yMeshInitiate)


    
        points = [firstInterSet.tolist(), secondInterSet.tolist()]
        values = [thirdInterSet.tolist()]
    
        data = interpolate.griddata((points[0], points[1]), values[0], (xTest, yTest), method='cubic')
    
        z_data = []
        for x in range(0, len(data)):
            combine = list(deepflatten(data[x], depth=1))
            z_data.append(combine)
        x_data = []
        combine = list(deepflatten(xTest, depth=1))
        x_data.append(combine)
    
        #y_data = []
        #combine = list(deepflatten(yTest, depth=1))
        #y_data.append(combine)
        y_data = np.linspace(-1,1,200)
        
        #fig = ff.create_quiver(XxPol, YyPol, Vs1PolX, Vs1PolY)
        fig = go.Figure()
        fig.add_trace(go.Contour(x=x_data[0], y=y_data, z=z_data, line_smoothing=1, showscale=True,  contours_coloring='heatmap',
            colorscale=[[0.0, "rgb(49,54,149)"],
                [0.1111111111111111, "rgb(69,117,180)"],
                [0.2222222222222222, "rgb(116,173,209)"],
                [0.3333333333333333, "rgb(171,217,233)"],
                [0.4444444444444444, "rgb(224,243,248)"],
                [0.5555555555555556, "rgb(254,224,144)"],
                [0.6666666666666666, "rgb(253,174,97)"],
                [0.7777777777777778, "rgb(244,109,67)"],
                [0.8888888888888888, "rgb(215,48,39)"],
                [1.0, "rgb(165,0,38)"]]
        ))

        fig.update_layout(
            yaxis=dict(range=[-2,2]),
            xaxis=dict(range=[-2,2]), 
            showlegend=True,
            height=1000,
            title={
                'text': 'VP',
                'xanchor':'center',
                'yanchor':'top',
                'x': 0.5,
                'y': 0.9
            }
            )
        #fig.update_xaxes(domain=(0.25, 0.75))
        #fig.update_yaxes(domain=(0.25, 0.75))

        fig.update_layout(dragmode='drawrect',
                    # style of new shapes
                    newshape=dict(line_color='yellow',
                                fillcolor='turquoise',
                                opacity=0.5),
                    plot_bgcolor='rgba(0,0,0,0)')


        fig.add_trace(
            go.Scatter(
            mode='markers',
            x=[0],
            y=[0],
            marker_symbol='circle-open',
            showlegend=False, 
            marker_size=599,
            marker_line_width=194,
            opacity=1.0,
            marker_line_color='white',
            marker_color='white',
            hoverinfo='skip'

         )
        )

                            
        return fig


    if plotType == 'VS1':
        firstInterSet = np.multiply(Uxyz[:,0], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))

        secondInterSet = np.multiply(Uxyz[:,1], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))
   
        thirdInterSet = Vs1


        xTest = yTest = np.linspace(-1,1,len(firstInterSet))
        xTest, yTest = np.meshgrid(xMeshInitiate, yMeshInitiate)


    
        points = [firstInterSet.tolist(), secondInterSet.tolist()]
        values = [thirdInterSet.tolist()]
    
        data = interpolate.griddata((points[0], points[1]), values[0], (xTest, yTest), method='cubic')
    
        z_data = []
        for x in range(0, len(data)):
            combine = list(deepflatten(data[x], depth=1))
            z_data.append(combine)
        x_data = []
        combine = list(deepflatten(xTest, depth=1))
        x_data.append(combine)
    
        #y_data = []
        #combine = list(deepflatten(yTest, depth=1))
        #y_data.append(combine)
        y_data = np.linspace(-1,1,200)
        
        #fig = ff.create_quiver(XxPol, YyPol, Vs1PolX, Vs1PolY)
        fig = go.Figure()
        fig.add_trace(go.Contour(x=x_data[0], y=y_data, z=z_data, line_smoothing=1, showscale=True, contours_coloring='heatmap',
            colorscale=[[0.0, "rgb(49,54,149)"],
                [0.1111111111111111, "rgb(69,117,180)"],
                [0.2222222222222222, "rgb(116,173,209)"],
                [0.3333333333333333, "rgb(171,217,233)"],
                [0.4444444444444444, "rgb(224,243,248)"],
                [0.5555555555555556, "rgb(254,224,144)"],
                [0.6666666666666666, "rgb(253,174,97)"],
                [0.7777777777777778, "rgb(244,109,67)"],
                [0.8888888888888888, "rgb(215,48,39)"],
                [1.0, "rgb(165,0,38)"]]
        ))
        fig.update_layout(
            yaxis=dict(range=[-2,2]),
            xaxis=dict(range=[-2,2]), 
            showlegend=True,
            height=1000,
            plot_bgcolor='rgba(0,0,0,0)',
            title={
                'text': 'VS1',
                'xanchor':'center',
                'yanchor':'top',
                'x': 0.5,
                'y': 0.9
            }
            )


        fig.add_trace(
            go.Scatter(
            mode='markers',
            x=[0],
            y=[0],
            marker_symbol='circle-open',
            showlegend=False, 
            marker_size=596,
            marker_line_width=192,
            opacity=1.0,
            marker_line_color='white',
            marker_color='white',
            hoverinfo='skip'
         )
        )

        return fig


    if plotType == 'VS2':
        firstInterSet = np.multiply(Uxyz[:,0], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))

        secondInterSet = np.multiply(Uxyz[:,1], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))
   
        thirdInterSet = Vs2
        xTest = yTest = np.linspace(-1,1,len(firstInterSet))
        xTest, yTest = np.meshgrid(xMeshInitiate, yMeshInitiate)

        points = [firstInterSet.tolist(), secondInterSet.tolist()]
        values = [thirdInterSet.tolist()]
    
        data = interpolate.griddata((points[0], points[1]), values[0], (xTest, yTest), method='cubic')
    
        z_data = []
        for x in range(0, len(data)):
            combine = list(deepflatten(data[x], depth=1))
            z_data.append(combine)
        x_data = []
        combine = list(deepflatten(xTest, depth=1))
        x_data.append(combine)
    
        #y_data = []
        #combine = list(deepflatten(yTest, depth=1))
        #y_data.append(combine)
        y_data = np.linspace(-1,1,200)
        
        #fig = ff.create_quiver(XxPol, YyPol, Vs1PolX, Vs1PolY)

        fig = go.Figure()
        fig.add_trace(go.Contour(x=x_data[0], y=y_data, z=z_data, line_smoothing=1,  showscale=True, contours_coloring='heatmap',
            colorscale=[[0.0, "rgb(49,54,149)"],
                [0.1111111111111111, "rgb(69,117,180)"],
                [0.2222222222222222, "rgb(116,173,209)"],
                [0.3333333333333333, "rgb(171,217,233)"],
                [0.4444444444444444, "rgb(224,243,248)"],
                [0.5555555555555556, "rgb(254,224,144)"],
                [0.6666666666666666, "rgb(253,174,97)"],
                [0.7777777777777778, "rgb(244,109,67)"],
                [0.8888888888888888, "rgb(215,48,39)"],
                [1.0, "rgb(165,0,38)"]]
        ))
        
        fig.update_layout(
            yaxis=dict(range=[-2,2]),
            xaxis=dict(range=[-2,2]), 
            showlegend=True,
            height=1000,
            plot_bgcolor='rgba(0,0,0,0)',
            title={
                'text': 'VS2',
                'xanchor':'center',
                'yanchor':'top',
                'x': 0.5,
                'y': 0.9
            }
            )


        fig.add_trace(
            go.Scatter(
            mode='markers',
            x=[0],
            y=[0],
            marker_symbol='circle-open',
            showlegend=False, 
            marker_size=599,
            marker_line_width=194,
            opacity=1.0,
            marker_line_color='white',
            marker_color='white',
            hoverinfo='skip'
         )
        )


        
        return fig

    if plotType == 'VPVS1':
        firstInterSet = np.multiply(Uxyz[:,0], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))

        secondInterSet = np.multiply(Uxyz[:,1], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))
   
        thirdInterSet = Vp/Vs1
        xTest = yTest = np.linspace(-1,1,len(firstInterSet))
        xTest, yTest = np.meshgrid(xMeshInitiate, yMeshInitiate)

        points = [firstInterSet.tolist(), secondInterSet.tolist()]
        values = [thirdInterSet.tolist()]
    
        data = interpolate.griddata((points[0], points[1]), values[0], (xTest, yTest), method='cubic')
    
        z_data = []
        for x in range(0, len(data)):
            combine = list(deepflatten(data[x], depth=1))
            z_data.append(combine)
        x_data = []
        combine = list(deepflatten(xTest, depth=1))
        x_data.append(combine)
    
        #y_data = []
        #combine = list(deepflatten(yTest, depth=1))
        #y_data.append(combine)
        y_data = np.linspace(-1,1,200)
        
        #fig = ff.create_quiver(XxPol, YyPol, Vs1PolX, Vs1PolY)
        fig = go.Figure()
        fig.add_trace(go.Contour(x=x_data[0], y=y_data, z=z_data, line_smoothing=1, zmin=1, zmax=3,  showscale=True, contours_coloring='heatmap',
            colorscale=[[0.0, "rgb(49,54,149)"],
                [0.1111111111111111, "rgb(69,117,180)"],
                [0.2222222222222222, "rgb(116,173,209)"],
                [0.3333333333333333, "rgb(171,217,233)"],
                [0.4444444444444444, "rgb(224,243,248)"],
                [0.5555555555555556, "rgb(254,224,144)"],
                [0.6666666666666666, "rgb(253,174,97)"],
                [0.7777777777777778, "rgb(244,109,67)"],
                [0.8888888888888888, "rgb(215,48,39)"],
                [1.0, "rgb(165,0,38)"]]
        ))
        fig.update_layout(
            yaxis=dict(range=[-2,2]),
            xaxis=dict(range=[-2,2]), 
            showlegend=True,
            height=1000,
            plot_bgcolor='rgba(0,0,0,0)',
            title={
                'text': 'VPVS1',
                'xanchor':'center',
                'yanchor':'top',
                'x': 0.5,
                'y': 0.9
            }
            )
        fig.add_trace(
            go.Scatter(
            mode='markers',
            x=[0],
            y=[0],
            marker_symbol='circle-open',
            showlegend=False, 
            marker_size=599,
            marker_line_width=194,
            opacity=1.0,
            marker_line_color='white',
            marker_color='white',
            hoverinfo='skip'
         )
        )


        
        return fig

    df = pd.DataFrame(list(zip(XxPol, YyPol, ZzPol, Vs1PolX, Vs1PolY, Vs1PolZ)), columns = ['x','y','z','u','v','w'])
    np.random.seed(20)
    remove_n = 1300
    drop_indices = np.random.choice(df.index, remove_n, replace=False)
    df = df.drop(drop_indices)
    index_list = df.index


    if  plotType=='3DQuiver':

        fig1 = make_subplots(rows=1, cols=1,
                            specs=[[{'is_3d': True}]],
                            subplot_titles=['Vs1 Polarization & splitting time (s/km)'],
                        )

        fig1.add_trace(go.Surface(x=Xx, y=Yy, z=Zz, surfacecolor=colorValues, showscale=False, 
                colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]    
        ))
        fig1.add_trace(go.Surface(z=z1, y=y1, x=x1, showscale=False))

        for t in index_list:
            fig1.add_trace(go.Cone(x=[df['x'][t]],y=[df['y'][t]],z=[df['z'][t]],u=[df['u'][t]],w=[df['w'][t]],v=[df['v'][t]], colorscale='Blues', showscale=False, sizemode='absolute', sizeref=0.15))
        
        fig1.update_layout(scene_camera_eye=dict(x=-0.76, y=1.8, z=0.92))
        fig1.update_layout(
            scene=dict(
            xaxis= dict(nticks=1, range=[-1,1], visible=False,),
            yaxis= dict(nticks=1, range=[-1,1], visible=False,),
            zaxis= dict(nticks=1, range=[-1,1], visible=False,),)
        )
        return fig1


    if  plotType=='3DVP':

        firstInterSet = np.multiply(Uxyz[:,0], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))

        secondInterSet = np.multiply(Uxyz[:,1], np.real(np.sqrt(np.divide(1, (1-Uxyz[:,2])))))
   
        thirdInterSet = Vp
        
        xTest = yTest = np.linspace(-1,1,len(firstInterSet))
        xTest, yTest = np.meshgrid(xMeshInitiate, yMeshInitiate)


    
        points = [firstInterSet.tolist(), secondInterSet.tolist()]
        values = [thirdInterSet.tolist()]
    
        data = interpolate.griddata((points[0], points[1]), values[0], (xTest, yTest), method='cubic')
    
        z_data = []
        for x in range(0, len(data)):
            combine = list(deepflatten(data[x], depth=1))
            z_data.append(combine)
        x_data = []
        combine = list(deepflatten(xTest, depth=1))
        x_data.append(combine)
    
        #y_data = []
        #combine = list(deepflatten(yTest, depth=1))
        #y_data.append(combine)
        y_data = np.linspace(-1,1,200)


        
        vpFig = make_subplots(rows=1, cols=1,
                        specs=[[{'is_3d': True}]],
                        subplot_titles=['VP (km/s)'],
                     )
        #print(x_data[0])
        print(np.shape(Xx), np.shape(Yy), np.shape(Zz))

        vpFig.add_trace(go.Surface(x=Xx, y=Yy, z=Zz, surfacecolor=velp*2.5,
                colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]
         ), 1, 1)

        #vpFig.add_trace(go.Surface(z=z1, y=y1, x=x1, showscale=False))
        vpFig.update_layout(
            scene=dict(
            xaxis= dict(nticks=5, range=[-1,1], visible=False,),
            yaxis= dict(nticks=5, range=[-1,1], visible=False,),
            zaxis= dict(nticks=5, range=[-1,1], visible=False,),)
        )




        return vpFig





    if plotType=='3DVS1':
        vs1Fig = make_subplots(rows=1, cols=1,
                          specs=[[{'is_3d': True}]],
                          subplot_titles=['Vs1 (km/s)'],
                     )
        vs1Fig.add_trace(go.Surface(x=Xx, y=Yy, z=Zz, surfacecolor=vels1*4,
                colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]
        
        ), 1, 1)
        vs1Fig.add_trace(go.Surface(z=z1, y=y1, x=x1, showscale=False))
        vs1Fig.update_layout(
            scene=dict(
            xaxis= dict(nticks=5, range=[-1,1], visible=False,),
            yaxis= dict(nticks=5, range=[-1,1], visible=False,),
            zaxis= dict(nticks=5, range=[-1,1], visible=False,),)
        )
        return vs1Fig

    if plotType=='3DVS2':
        vs2Fig = make_subplots(rows=1, cols=1,
                            specs=[[{'is_3d': True}]],
                            subplot_titles=['Vs2 (km/s)'],
                       )
        vs2Fig.add_trace(go.Surface(x=Xx, y=Yy, z=Zz, surfacecolor=vels2*4,
                colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]
        
        ), 1, 1)
        vs2Fig.add_trace(go.Surface(z=z1, y=y1, x=x1, showscale=False))
        vs2Fig.update_layout(
            scene=dict(
            xaxis= dict(nticks=5, range=[-1,1], visible=False,),
            yaxis= dict(nticks=5, range=[-1,1], visible=False,),
            zaxis= dict(nticks=5, range=[-1,1], visible=False,),)
        )
        return vs2Fig

    if plotType=='3DVPVS1':
        vpvs1 = np.divide(velp, vels1)

        vpvs1Fig = make_subplots(rows=1, cols=1,
                            specs=[[{'is_3d': True}]],
                            subplot_titles=['VP/VS1 (km/s)'],
                       )

        vpvs1Fig.add_trace(go.Surface(x=Xx, y=Yy, z=Zz, surfacecolor=vpvs1*4,
                colorscale=[[0.0, "rgb(165,0,38)"],
                [0.1111111111111111, "rgb(215,48,39)"],
                [0.2222222222222222, "rgb(244,109,67)"],
                [0.3333333333333333, "rgb(253,174,97)"],
                [0.4444444444444444, "rgb(254,224,144)"],
                [0.5555555555555556, "rgb(224,243,248)"],
                [0.6666666666666666, "rgb(171,217,233)"],
                [0.7777777777777778, "rgb(116,173,209)"],
                [0.8888888888888888, "rgb(69,117,180)"],
                [1.0, "rgb(49,54,149)"]]
        
        ), 1, 1)
        vpvs1Fig.add_trace(go.Surface(z=z1, y=y1, x=x1, showscale=False))
        vpvs1Fig.update_layout(
            scene=dict(
            xaxis= dict(nticks=5, range=[-1,1], visible=False,),
            yaxis= dict(nticks=5, range=[-1,1], visible=False,),
            zaxis= dict(nticks=5, range=[-1,1], visible=False,),)
        )
        return vpvs1Fig




    



def print_csv_table():
    columnNames = ["Paper Reference", "tensor #", "Rock Type", "density (g/cm3)", "C11 (Mbar)", "C12", "C13","C14", "C15", "C16", "C22", "C23", "C24", "C25", "C26", "C33", "C34", "C35", "C36", "C44", "C45", "C46", "C55", "C56", "C66"]
    fileLoc = "tensor_scripts_info/DB_Tensors_Rhos_OrigOrientation_CSV.csv"
    dbFile = pd.read_csv(fileLoc, names=columnNames, sep=',', engine='python')
    dbFrame = pd.DataFrame(data=dbFile, columns=columnNames)
    #print(dbFile)
   
    #print(dbFrame)

    maxRows = len(dbFrame.index)
    csvOutput = dbFrame.to_csv(index=False, encoding='utf-8')
    #print(dbFrame)

    dbDataTable = dash_table.DataTable(
        id='db_csv_table',
        columns=[{"name":i,"id": i, "deletable": True, "selectable": True} for i in dbFrame.columns],
        data=dbFrame.to_dict('records'),
        export_columns='visible',
        selected_rows=[],
        export_format='csv',
        export_headers='names',
        page_action='native',
        page_size=100,
        filter_action='native',
        row_selectable="multi",
        row_deletable=True,
        editable='true',
        style_cell_conditional=[{
            'if': {'column_id': 'Remark'},
            'textAlign': 'left'

        }],

        style_table={'height': '350px', 'overflowY': 'auto', 'text-align': 'left'},
    )

    return dbDataTable

def print_breakdown():
    columnNames = ["Isotropic", "Hexagonal", "Orthorhombic", "Tetragonal", "Monoclinic", "Triclinic", "0", "0.", "Backus'.", "Backus'._", "Backus',", "Backus' ", "Backus'  ", "Love_A", "Love_C", "Love_F", "Love_L", "Love_N", "Eta", "EtaK", "Eigs2' ", "Eigs2'  ", "Eigs'2.", "Bisectrix[:,1]", "Bisectrix[:,1] ", "Bisectrix[:,1]  ", "Bisectrix[:,2]", "Bisectrix[:,2] ", "Bisectrix[:,2]  ", "Bisectrix{:,3]", "Bisectrix[:,3] ", "Bisectrix[,:3]  "]
    fileLoc = "tensor_scripts_info/BreakdownTest.txt"
    try:
        dbFile = pd.read_csv(fileLoc, names=columnNames, delim_whitespace=True, engine='python')
        dbFrame = pd.DataFrame(data=dbFile, columns=columnNames)
    except:
        return
    #print(dbFile)
   
    #print(dbFrame)

    maxRows = len(dbFrame.index)
    csvOutput = dbFrame.to_csv(index=False, encoding='utf-8')
    #print(dbFrame)

    dbDataTable = dash_table.DataTable(
        id='db_breakdown_table',
        columns=[{"name":i,"id": i, "deletable": True, "selectable": True} for i in dbFrame.columns],
        data=dbFrame.to_dict('records'),
        export_columns='visible',
        selected_rows=[],
        export_format='csv',
        export_headers='names',
        page_action='native',
        page_size=100,
        filter_action='native',
        row_selectable="multi",
        row_deletable=True,
        editable='true',
        style_cell_conditional=[{
            'if': {'column_id': 'Remark'},
            'textAlign': 'left'

        }],

        style_table={'height': '150px', 'overflowY': 'auto', 'text-align': 'left', 'overflowX':'scroll'},
    )

    return dbDataTable

def print_iso_decomp():
    columnNames = ["test", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21"]
    fileLoc = "tensor_scripts_info/IsotropicComponentsTest.txt"
    try:
        dbFile = pd.read_csv(fileLoc, names=columnNames, delim_whitespace=True, engine='python')
        dbFrame = pd.DataFrame(data=dbFile, columns=columnNames)
    except:
        return
    #print(dbFile)
   
    #print(dbFrame)

    maxRows = len(dbFrame.index)
    csvOutput = dbFrame.to_csv(index=False, encoding='utf-8')
    #print(dbFrame)

    dbDataTable = dash_table.DataTable(
        id='isotropic_components_table',
        columns=[{"name":i,"id": i, "deletable": True, "selectable": True} for i in dbFrame.columns],
        data=dbFrame.to_dict('records'),
        export_columns='visible',
        selected_rows=[],
        export_format='csv',
        export_headers='names',
        page_action='native',
        page_size=100,
        filter_action='native',
        row_selectable="multi",
        row_deletable=True,
        editable='true',
        style_cell_conditional=[{
            'if': {'column_id': 'Remark'},
            'textAlign': 'left'

        }],

        style_table={'height': '150px', 'overflowY': 'auto', 'text-align': 'left', 'overflowX':'scroll'},
    )

    return dbDataTable


def print_hexag_decomp():
    columnNames = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21"]
    fileLoc = "tensor_scripts_info/HexagonalComponentsTest.txt"
    try:
        dbFile = pd.read_csv(fileLoc, names=columnNames, delim_whitespace=True, engine='python')
        dbFrame = pd.DataFrame(data=dbFile, columns=columnNames)
    except:
        return
    #print(dbFile)
   
    #print(dbFrame)

    maxRows = len(dbFrame.index)
    csvOutput = dbFrame.to_csv(index=False, encoding='utf-8')
    #print(dbFrame)

    dbDataTable = dash_table.DataTable(
        id='hexagonal_components_table',
        columns=[{"name":i,"id": i, "deletable": True, "selectable": True} for i in dbFrame.columns],
        data=dbFrame.to_dict('records'),
        export_columns='visible',
        selected_rows=[],
        export_format='csv',
        export_headers='names',
        page_action='native',
        page_size=100,
        filter_action='native',
        row_selectable="multi",
        row_deletable=True,
        editable='true',
        style_cell_conditional=[{
            'if': {'column_id': 'Remark'},
            'textAlign': 'left'

        }],

        style_table={'height': '750px', 'overflowY': 'auto', 'text-align': 'left', 'overflowX':'scroll'},
    )
    hexTableList = return_hexag_decomp_table(dbFrame.to_dict('records'))

    return dbDataTable, hexTableList

def return_hexag_decomp_table(hexTable=None):
    hexList = []
    for x in hexTable[0]:
        hexList.append(hexTable[0][x])

    return hexList



def tv_averaging(t1, t2, t3, user_input=False, plotType3D='None'):
    christoffelParameters = ChristoffelDevParams.ChristoffelParameters()
    Res = 3
    pi = math.pi
    aggTensorColumns = christoffelParameters.columnNamesTensorCSV
    sphereColumnNames = [x for x in range(0, 121)]
    csv_tensor_number = [x for x in range(0, 50)]
    user_tensor_number = [x for x in range(97, 147)]
    user_to_csv_mapping = zip(user_tensor_number, csv_tensor_number)
    user_to_csv_mapping = dict(user_to_csv_mapping)
    weight = 0

    counter = 0
    #aggTensorCSVLocation = 'NSFProject/AllAggTensorsCSV.csv'
    aggTensorCSVLocation = 'tensor_scripts_info/DB_Tensors_Rhos_OrigOrientation_CSV.csv'
    if user_input==True:
        aggTensorCSVLocation = 'tensor_scripts_info/user_input.csv'
    tensors_to_average=[t1,t2,t3]
    #print(t1,t2,t3)
    tensorDF = pd.read_csv(aggTensorCSVLocation, sep=',', engine='python')

    Cijs = np.zeros((3,21), dtype=float)
    Rhos = np.zeros((3,1), dtype=float)
    for i in range(0,3):
        for j in range(3,24):
            Cijs[i,j-3] = tensorDF.iloc[tensors_to_average[i],j]
    for i in range(0,3):
        for j in range(2,3):
            Rhos[i,j-2] = tensorDF.iloc[tensors_to_average[i],j]
    Equal = 0
    #make sure to add customization for weight , options able to be selected from dropdown? input?
    wt = [2,1,1]
    #print(Cijs[0,:])

    wt = wt/np.sum(wt)
    if Equal == 1:
        wt = np.ones((3,1)*(1/3))
    tensorsV = []
    tensorsR = []
    V_ave = np.zeros((36,1), dtype=float)
    R_ave = np.zeros((36,1), dtype=float)


    
    for array in range(0,3):
        tensorsV.append(np.zeros((6,6),dtype=float))
        tensorsR.append(np.zeros((6,6),dtype=float))
    for i in range(0,3):
        C = Cijs[i,:]
        #all indicies below are subtracted by 1 for indexing purposes
        tensorsV[i] = [[C[0], C[1], C[2], C[3], C[4], C[5]], 
        [C[1], C[2],C[3],C[4], C[5],C[6]], 
        [C[2], C[7], C[11], C[12], C[13], C[14]], 
        [C[3], C[8], C[12], C[15], C[16],C[17]],
        [C[4], C[9], C[13], C[16], C[19],C[20]],
        [C[5], C[10], C[14], C[17], C[19], C[20]]
        ]
        tensorsV[i] = np.asarray(tensorsV[i])


    # CHECK THE STUPID INVERSE FUNCTION
    for i in range(0,3):
        tensorsR[i] = np.linalg.pinv(tensorsV[i])

    
    for i in range(0,36):
        PV = np.zeros((3,1), dtype=float)
        PR = np.zeros((3,1), dtype=float)
        for j in range(0,3):
            flattenedVTensor = tensorsV[j].flatten()
            flattenedRTensor = tensorsR[j].flatten()
            PV[j,] = (1/3)*flattenedVTensor[i]
            PR[j,] = (1/3)*flattenedRTensor[i]
        V_ave[i] = np.sum(PV)
        R_ave[i] = np.sum(PR)
    test_array = np.zeros((6,6), dtype=float)

    #re-do average arrays
    
    V_ave = np.reshape(V_ave, (6,6))
    R_ave = np.reshape(R_ave, (6,6))
    V_ave = V_ave.flatten()
    V_ave = V_ave.tolist()

    V_ave_rounded = []
    R_ave_rounded = []

    for x in V_ave:
        y = round(x,4)
        V_ave_rounded.append(y)


    return V_ave_rounded, R_ave





def decomposition(tensor_index, user_input=False, plotType='None'):



    christoffelParameters = ChristoffelDevParams.ChristoffelParameters()
    Res = 3
    pi = math.pi
    aggTensorColumns = christoffelParameters.columnNamesTensorCSV
    sphereColumnNames = [x for x in range(0, 121)]
    csv_tensor_number = [x for x in range(0, 50)]
    user_tensor_number = [x for x in range(97, 147)]
    user_to_csv_mapping = zip(user_tensor_number, csv_tensor_number)
    user_to_csv_mapping = dict(user_to_csv_mapping)

    #aggTensorCSVLocation = 'NSFProject/AllAggTensorsCSV.csv'
    aggTensorCSVLocation = 'tensor_scripts_info/DB_Tensors_Rhos_OrigOrientation_CSV.csv'
    if user_input==True:
        aggTensorCSVLocation = 'tensor_scripts_info/user_input.csv'
    sampleN = 1
    VRHNumber = 1
    C = []

    minNum = christoffelParameters.minNum
    Samps = 3

    tensorDF = pd.read_csv(aggTensorCSVLocation, sep=',', engine='python')
    FigName = 'Sample {} Phase={} VRH = {}'.format(str(sampleN), str(minNum), str(VRHNumber))

    #print(aggTensorCSVLocation)
    tensorIndex = int(tensor_index)
    #print(tensorDF)
    ### MAP VALUES TO DICTIONARY VALUES SO THAT IT MAPS PROPERLY - USER INPUT ILOC IS 0,1...N instead of 97...N
    #print(tensorDF.iloc[1, 4:25])
    if user_input == True:
        tensorIndex = user_to_csv_mapping[tensorIndex]
        tensorList = (tensorDF.iloc[tensorIndex, 4:25])
    else:
        #tensorList = (tensorDF.iloc[tensorIndex-1, 4:25])
        #print(tensorDF.iloc[0:, 4:25])
        tensorList = (tensorDF.iloc[0:, 1:25])



    tensors = tensorDF.iloc[0:, 4:25]

    breakDown = np.zeros((len(tensors),32))
    symmetryAxis = np.zeros((len(tensors), 21))
    isoComponent = np.zeros((len(tensors), 21))
    hexagonalComponent = np.zeros((len(tensors), 21))


    for s in range (0, 1):
        cInitial = [[tensors.iloc[tensor_index, 0],tensors.iloc[tensor_index, 1],tensors.iloc[tensor_index, 2],tensors.iloc[tensor_index, 3],tensors.iloc[tensor_index, 4],tensors.iloc[tensor_index, 5]],
             [tensors.iloc[tensor_index, 1],tensors.iloc[tensor_index, 6],tensors.iloc[tensor_index, 7],tensors.iloc[tensor_index, 8],tensors.iloc[tensor_index,9],tensors.iloc[tensor_index, 10]],
             [tensors.iloc[tensor_index, 2],tensors.iloc[tensor_index, 7],tensors.iloc[tensor_index, 11],tensors.iloc[tensor_index, 12],tensors.iloc[tensor_index, 13],tensors.iloc[tensor_index, 14]],
             [tensors.iloc[tensor_index, 3],tensors.iloc[tensor_index, 8],tensors.iloc[tensor_index, 12],tensors.iloc[tensor_index, 15],tensors.iloc[tensor_index, 16],tensors.iloc[tensor_index, 17]],
             [tensors.iloc[tensor_index, 4],tensors.iloc[tensor_index, 9],tensors.iloc[tensor_index, 13],tensors.iloc[tensor_index, 16],tensors.iloc[tensor_index, 18],tensors.iloc[tensor_index, 19]],
             [tensors.iloc[tensor_index, 5],tensors.iloc[tensor_index, 10],tensors.iloc[tensor_index, 14],tensors.iloc[tensor_index, 17],tensors.iloc[tensor_index, 19],tensors.iloc[tensor_index, 20]]
             ]
            
        dij = [[cInitial[0][0]+cInitial[0][1]+cInitial[0][2], cInitial[0][5]+cInitial[1][5]+cInitial[2][5], cInitial[0][4]+cInitial[1][4]+cInitial[2][4] ],
            [cInitial[0][5]+cInitial[1][5]+cInitial[2][5], cInitial[0][1]+cInitial[1][1]+cInitial[2][1], cInitial[0][3]+cInitial[1][3]+cInitial[2][3] ],
            [cInitial[0][4]+cInitial[1][4]+cInitial[2][4], cInitial[0][3]+cInitial[1][3]+cInitial[2][3], cInitial[0][2]+cInitial[1][2]+cInitial[2][2] ] 
        ]
     

        vij = [[ cInitial[0][0]+cInitial[5][5]+cInitial[4][4], cInitial[0][5]+cInitial[1][5]+cInitial[3][4], cInitial[0][4]+cInitial[2][4]+cInitial[3][5]  ],
        [ cInitial[0][5]+cInitial[1][5]+cInitial[3][4], cInitial[5][5]+cInitial[1][1]+cInitial[3][3], cInitial[1][3]+cInitial[2][3]+cInitial[4][5] ],
        [ cInitial[0][4]+cInitial[2][4]+cInitial[3][5], cInitial[1][3]+cInitial[2][3]+cInitial[4][5], cInitial[4][4]+cInitial[3][3]+cInitial[2][2] ]
        ]


        eigenVals_dij, eigenVecs_dij = np.linalg.eig(dij)
        eigenVals_vij, eigenVecs_vij = np.linalg.eig(vij)
        eigenVecs_dij = np.column_stack((eigenVecs_dij[:,2], -1*eigenVecs_dij[:,1], eigenVecs_dij[:,0]))
        eigenVecs_vij = np.column_stack((eigenVecs_vij[:,2], eigenVecs_vij[:,1], -1*eigenVecs_vij[:,0]))
        eigs = np.diag(eigenVals_dij)
        eigsTwo = np.diag(eigenVals_vij)

    

        aOne = eigs[0][0]-eigs[1][1]
        aOne = aOne * -1
        aTwo = eigs[2][2]-eigs[1][1]


        aOneTwo = eigsTwo[1][1]- eigsTwo[0][0]
        aTwoTwo = eigsTwo[2][2]- eigsTwo[1][1]


        if aOne < aTwo:
            eigenVecs_dij = eigenVecs_dij[:, [2,1,0]]
            eigs = eigs[[2,1,0]]

        if aOneTwo < aTwoTwo:
            eigenVecs_vij  = eigenVecs_vij[:, [2,1,0]]
            eigsTwo = eigsTwo[[2,1,0]]

        Ang = np.empty([3,3])
        AngTwo = np.empty([3,3])
        
        for i in range(0, 3):
            for j in range(0, 3):

                Ang[i,j] = math.degrees(math.acos(np.dot(eigenVecs_vij[:,i], eigenVecs_dij[:,j])))
                AngTwo[i,j] = math.degrees(math.acos(np.dot(eigenVecs_vij[:,i], -1*eigenVecs_dij[:,j])))

        eVd = eigenVecs_dij
        AngF = Ang
        for i in range(0,3):
            if np.amin(AngTwo[:,i]) < np.amin(Ang[:,i]):
                eVd[:,i] = -1*eVd[:,i]
                AngF[:,i] = AngTwo[:,i]

        Bisectrix = np.empty([3,3])
        BA = np.empty([3,3])

        for i in range(0,3):
            I = np.where(AngF[:,i]==np.min(AngF[:,i]))

            Bisectrix[:,i] = np.divide((np.add(eigenVecs_vij[:,I[0][0]], eVd[:,i])), 2)
            Bisectrix[:,i] = Bisectrix[:,i] / np.linalg.norm(Bisectrix[:,i])
        Bisectrix = np.column_stack((Bisectrix[:,1], Bisectrix[:,0], Bisectrix[:,2]))

        

        BisectrixOne = Bisectrix
        BisectrixOne[:,1] = -1*np.cross(BisectrixOne[:,2], Bisectrix[:,1])
        BisectrixOne[:,0] = -1*np.cross(BisectrixOne[:,0], Bisectrix[:,2])
        BisectrixAll = np.array([BisectrixOne, BisectrixOne[:,[0,1,2]], BisectrixOne[:,[1,0,2]], BisectrixOne[:, [1,2,0]], BisectrixOne[:,[2,0,1]], BisectrixOne[:,[2,1,0]] ])
        ### line 106-111 in matlab code
        IsoA = np.zeros([6,1])
        HexA = np.zeros([6,1])
        TetA = np.zeros([6,1])
        OrthoA = np.zeros([6,1])
        MonA = np.zeros([6,1])
        TricA = np.zeros([6,1])



        for btrix in range (0, len(BisectrixAll)):
            K2 = np.empty([3,3])
            K3 = np.empty([3,3])
            K4 = np.empty([3,3])
            Omega = BisectrixAll[btrix].conj()
            K1 = Omega**2

            for i in range (0,3):
                for j in range(0, 3):
                    K2[i,j] = Omega[i, round((j)%2.00001)]*Omega[i, round((j+1)%2.00001)]
                    K3[i,j] = Omega[round((i)%3), j ]*Omega[round((i+1)%3), j]
                    K4[i,j] = Omega[round((i)%3),round((j)%3) ]*Omega[round((i+1)%3), round((j+1)%3)] + Omega[round((1)%3),round((j+1)%3)]*Omega[round((i+1)%3), round((j)%3)]
            K_a = np.concatenate((K1, 2*K2), axis=1)
            K_b = np.concatenate((K3, K4), axis=1)
            K = np.concatenate((K_a, K_b))
            #C = K * cInitial * K.conj().transpose()
            C = np.matmul(K, cInitial)
            C = np.matmul(C, K.conj())


            symmetryAxis = np.empty((s,1))
            symmetryAxis = [C[0][0:5], C[1][1:5], C[2][2:5],C[3][3:5], C[4][4:5], C[5][5] ]
            ###Note 1/11/22 at office - check Vec_1 
            Vec_1 = [[C[0][0]], [C[1][1]], [C[2][2]], 
            [math.sqrt(2)*C[1][2]], [math.sqrt(2)*C[0][2]], [math.sqrt(2)*C[0][1]], 
            [2*C[3][3]], [2*C[4][4]], [2*C[5][5]], 
            [2*C[0][3]], [2*C[1][4]], [2*C[2][5]], [2*C[2][3]], [2*C[0][4]], 
            [2*C[1][5]], [2*C[1][3]], 
            [2*C[2][4]], [2*C[0][5]], [2*math.sqrt(2)*C[4][5]], [2*math.sqrt(2)*C[3][5]], 
            [2*math.sqrt(2)*C[3][4]]
            ]
            Vec_1 = np.array(Vec_1)




        Iso_proj = np.zeros([21,21])
        Iso_proj[0:3, 0:3] = 3/15
        

        Iso_proj[3:6, 3:6] = 4/15
   

        Iso_proj[6:9, 6:9] = 1/5


        Iso_proj[0:3, 6:9] = 2/15

  
        Iso_proj[6:9, 0:3] = 2/15



        Iso_proj[0:3, 3:6] = math.sqrt(2)/15



        Iso_proj[3:6, 0:3] = math.sqrt(2)/15

        Iso_proj[3:6, 6:9] = -1*math.sqrt(2)/15

        Iso_proj[6:9, 3:6] = -1*math.sqrt(2)/15





        Vec_iso = np.matmul(Vec_1.conj().T, Iso_proj)




        MultsList = [1,1,1,1/math.sqrt(2), 1/math.sqrt(2) ,1/math.sqrt(2),1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2,1/2, 1/(2*math.sqrt(2)), 1/(2*math.sqrt(2)), 1/(2*math.sqrt(2))]
        Mults = np.zeros((1,21))
        for x in range (0,21):
          Mults[0,x] = MultsList[x]


        E_iso = Vec_iso * Mults
        print(E_iso)


        Iso_tensor= [[E_iso[0][0], E_iso[0][5], E_iso[0][4], E_iso[0][9], E_iso[0][13], E_iso[0][17]],
        [E_iso[0][5], E_iso[0][1], E_iso[0][3], E_iso[0][15], E_iso[0][10], E_iso[0][14]],
        [E_iso[0][4], E_iso[0][3], E_iso[0][2], E_iso[0][12], E_iso[0][16], E_iso[0][11]],
        [E_iso[0][9], E_iso[0][15], E_iso[0][12], E_iso[0][6], E_iso[0][20], E_iso[0][19]],
        [E_iso[0][13], E_iso[0][10], E_iso[0][16], E_iso[0][20], E_iso[0][7], E_iso[0][18]],
        [E_iso[0][17], E_iso[0][14], E_iso[0][11], E_iso[0][19], E_iso[0][18], E_iso[0][8] ]]
        print(Iso_tensor)


        Iso_tensor = np.array(Iso_tensor)
        isoComponent = np.zeros([1,21])
       # print(Iso_tensor[0][0:8])

    

        isoComponent[0,0:6] = Iso_tensor[0][0:6]
        isoComponent[0,6:11] = Iso_tensor[1][1:6]
        isoComponent[0, 11:15] = Iso_tensor[2][2:6]
        isoComponent[0, 15:18] = Iso_tensor[3][3:6] 
        isoComponent[0, 18:20] = Iso_tensor[4][4:6] 
        isoComponent[0, 20:21] = Iso_tensor[5][5:6]





        Vec_2 = np.subtract(Vec_1.conj().T, Vec_iso)
        #print(np.divide(np.linalg.norm(Vec_2), np.linalg.norm(Vec_1)))


        Iso = (1-(np.divide((np.linalg.norm(Vec_2/100)), np.linalg.norm(Vec_1))))*100
        print(Iso)







    return 1
    

#tv_averaging(2,9,9)


calculate_tensor_symmetries(8)







